From 41f4354aa9e2db14603860a985b2ba509c8d1fac Mon Sep 17 00:00:00 2001
From: ruslanbay <67730802+ruslanbay@users.noreply.github.com>
Date: Tue, 25 Nov 2025 15:46:16 +0100
Subject: [PATCH 4/9] IPU4: add /drivers/media/platform/intel/ from
 https://github.com/intel/linux-intel-lts/tree/lts-v5.15.195-android_t-251103T063840Z/drivers/media/platform/intel

---
 drivers/media/platform/Kconfig                |    1 +
 drivers/media/platform/Makefile               |    1 +
 drivers/media/platform/intel/Kconfig          |  114 ++
 drivers/media/platform/intel/Makefile         |   21 +
 drivers/media/platform/intel/ipu4-acpi.c      | 1035 ++++++++++
 .../media/platform/intel/ipu4-bxt-gp-pdata.c  |  123 ++
 .../media/platform/intel/ipu4-bxt-p-pdata.c   | 1708 +++++++++++++++++
 .../platform/intel/ipu4p-icl-rvp-pdata.c      |  182 ++
 8 files changed, 3185 insertions(+)
 create mode 100644 drivers/media/platform/intel/Kconfig
 create mode 100644 drivers/media/platform/intel/Makefile
 create mode 100644 drivers/media/platform/intel/ipu4-acpi.c
 create mode 100644 drivers/media/platform/intel/ipu4-bxt-gp-pdata.c
 create mode 100644 drivers/media/platform/intel/ipu4-bxt-p-pdata.c
 create mode 100644 drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c

diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 80321e03809a..35b467dfe785 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -171,6 +171,7 @@ source "drivers/media/platform/xilinx/Kconfig"
 source "drivers/media/platform/rcar-vin/Kconfig"
 source "drivers/media/platform/atmel/Kconfig"
 source "drivers/media/platform/sunxi/Kconfig"
+source "drivers/media/platform/intel/Kconfig"
 
 config VIDEO_TI_CAL
 	tristate "TI CAL (Camera Adaptation Layer) driver"
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 73ce083c2fc6..c95db6ad0c94 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -86,3 +86,4 @@ obj-$(CONFIG_VIDEO_QCOM_VENUS)		+= qcom/venus/
 obj-y					+= sunxi/
 
 obj-$(CONFIG_VIDEO_MESON_GE2D)		+= meson/ge2d/
+obj-y += intel/
diff --git a/drivers/media/platform/intel/Kconfig b/drivers/media/platform/intel/Kconfig
new file mode 100644
index 000000000000..ac85770eca86
--- /dev/null
+++ b/drivers/media/platform/intel/Kconfig
@@ -0,0 +1,114 @@
+config INTEL_IPU4_BXT_P_PDATA
+	bool "Enable built in platform data for Broxton-P"
+	depends on VIDEO_INTEL_IPU && VIDEO_INTEL_IPU4
+	help
+		Pre-ACPI system platform data is compiled inside kernel
+
+config INTEL_IPU4_BXT_GP_PDATA
+	bool "Enable built in platform data for Broxton-P"
+	depends on VIDEO_INTEL_IPU && VIDEO_INTEL_IPU4
+	help
+		Pre-ACPI system platform data is compiled inside kernel
+
+config INTEL_IPU4P_ICL_RVP_PDATA
+	bool "Enable built in platform data for ipu4p"
+	depends on VIDEO_INTEL_IPU && VIDEO_INTEL_IPU4P
+	help
+		Pre-ACPI system platform data is compiled inside kernel
+
+config INTEL_IPU4_OV2740
+	bool "Compile platform data for OV2740"
+	depends on INTEL_IPU4_BXT_P_PDATA
+
+config INTEL_IPU4_IMX185
+	bool "Compile platform data for IMX185"
+	depends on INTEL_IPU4_BXT_P_PDATA
+
+config INTEL_IPU4_AR023Z
+	bool "Compile platform data for AR023Z"
+	help
+		Onsemi 2MP AR023Z camera sensor
+
+config INTEL_IPU4_IMX477
+	bool "Compile platform data for IMX477 camera sensor"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	help
+		Sony IMX477 sensor is enabled for DUAL Camera input.
+
+config INTEL_IPU4_OV13860
+	bool "Compile platform data for OV13860"
+	help
+		Omnivision 13MP camera sensor
+
+config INTEL_IPU4_OV9281
+	bool "Compile platform data for OV9281"
+	help
+		Omnivision 1MP camera sensor
+
+config INTEL_IPU4_OV10635
+	bool "Compile platform data for OV10635"
+	help
+		Omnivision 1MP camera sensor
+
+config INTEL_IPU4_AR0231AT
+        bool "Compile platform data for AR0231AT"
+        help
+	        AR0231 camera sensor for MAXIM 9286
+
+config INTEL_IPU4_MAGNA
+	bool "Compile platform data for MAGNA"
+        depends on INTEL_IPU4_BXT_P_PDATA
+	help
+		MAGNA Camera Sensor
+
+config INTEL_IPU4_IMX274
+	bool "Compile platform data for IMX274 camera sensor"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	help
+		Sony 14MP camera sensor is enabled for HDR function.
+
+config INTEL_IPU4_OV10640
+	bool "Compile platform data for OV10640"
+	help
+		  Omnivision 1.4MP camera sensor
+
+config INTEL_IPU4_ADV7481
+	bool "Compile platform data for ADV7481"
+	help
+		HDMI2MIPI convertor device ADV7481
+
+config INTEL_IPU4_ADV7481_EVAL
+	bool "Compile platform data for ADV7481 evaluation board"
+	help
+		HDMI2MIPI convertor device ADV7481 eval board
+
+config INTEL_IPU4_IMX290
+	bool "Compile platform data for IMX290"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	help
+		"Sony 8MB camera sensor is enabled for HDR function"
+
+config INTEL_IPU4_OX03A10
+	bool "Compile platorm data for OX03A10"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	help
+		"ox03a10 camera sensor"
+
+config INTEL_IPU4_OX03A10_FICOSA
+	bool "Compile platorm data for OX03A10 FICOSA"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	help
+		"ox03a10 ficosa camera sensor"
+
+config INTEL_IPU4_OV495
+	bool "Compile platorm data for OV495"
+	depends on INTEL_IPU4_BXT_P_PDATA
+	help
+		"ov495 camera sensor"
+
+config INTEL_IPU4_ADV7481_I2C_ID
+        int "I2C bus ID for ADV7481"
+        range 0 8
+        default 0
+        help
+	        I2C bus number of ADV7481 Mondello
diff --git a/drivers/media/platform/intel/Makefile b/drivers/media/platform/intel/Makefile
new file mode 100644
index 000000000000..67c52487b519
--- /dev/null
+++ b/drivers/media/platform/intel/Makefile
@@ -0,0 +1,21 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
+
+ifneq ($(EXTERNAL_BUILD), 1)
+srcpath := $(srctree)
+endif
+
+# force check the compile warning to make sure zero warnings
+# note we may have build issue when gcc upgraded.
+ccflags-y += $(call cc-disable-warning, unused-parameter)
+ccflags-y += $(call cc-disable-warning, implicit-fallthrough)
+ccflags-y += $(call cc-disable-warning, missing-field-initializers)
+ccflags-$(CONFIG_VIDEO_INTEL_IPU_WERROR) += -Werror
+
+ccflags-y += -I$(srcpath)/$(src)/../../../../include/
+ccflags-y += -I$(srcpath)/$(src)/../../pci/intel/
+
+obj-$(CONFIG_INTEL_IPU4_BXT_P_PDATA)   += ipu4-bxt-p-pdata.o
+obj-$(CONFIG_INTEL_IPU4_BXT_GP_PDATA)   += ipu4-bxt-gp-pdata.o
+obj-$(CONFIG_INTEL_IPU4P_ICL_RVP_PDATA)   += ipu4p-icl-rvp-pdata.o
+obj-$(CONFIG_VIDEO_INTEL_IPU)   += ipu4-acpi.o
diff --git a/drivers/media/platform/intel/ipu4-acpi.c b/drivers/media/platform/intel/ipu4-acpi.c
new file mode 100644
index 000000000000..cbdb901f0f09
--- /dev/null
+++ b/drivers/media/platform/intel/ipu4-acpi.c
@@ -0,0 +1,1035 @@
+/*
+ * Copyright (c) 2016--2018 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/acpi.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/gpio/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/gpio-regulator.h>
+#include <linux/regulator/machine.h>
+#include <linux/list.h>
+
+#include <media/crlmodule.h>
+#include <media/ipu4-acpi.h>
+#include <media/as3638.h>
+#include <media/lm3643.h>
+#include <media/lc898122.h>
+#include <media/dw9714.h>
+#include "../../i2c/ccs/ccs.h"
+
+#define HID_BUFFER_SIZE 32
+#define VCM_BUFFER_SIZE 32
+
+/* Data representation as it is in ACPI SSDB buffer */
+struct sensor_bios_data_packed {
+	u8 version;
+	u8 sku;
+	u8 guid_csi2[16];
+	u8 devfunction;
+	u8 bus;
+	u32 dphylinkenfuses;
+	u32 clockdiv;
+	u8 link;
+	u8 lanes;
+	u32 csiparams[10];
+	u32 maxlanespeed;
+	u8 sensorcalibfileidx;
+	u8 sensorcalibfileidxInMBZ[3];
+	u8 romtype;
+	u8 vcmtype;
+	u8 platforminfo;
+	u8 platformsubinfo;
+	u8 flash;
+	u8 privacyled;
+	u8 degree;
+	u8 mipilinkdefined;
+	u32 mclkspeed;
+	u8 controllogicid;
+	u8 reserved1[3];
+	u8 mclkport;
+	u8 reserved2[13];
+} __packed;
+
+/* Fields needed by ipu4 driver */
+struct sensor_bios_data {
+	struct device *dev;
+	u8 link;
+	u8 lanes;
+	u8 vcmtype;
+	u8 flash;
+	u8 degree;
+	u8 mclkport;
+	u32 mclkspeed;
+	u16 xshutdown;
+};
+
+static LIST_HEAD(devices);
+static LIST_HEAD(new_devs);
+
+struct ipu4_i2c_helper {
+	int (*fn)(struct device *, void *,
+		  struct ipu_isys_csi2_config *csi2,
+		  bool reprobe);
+	void *driver_data;
+};
+
+struct ipu4_i2c_new_dev {
+	struct list_head list;
+	struct i2c_board_info info;
+	unsigned short int bus;
+};
+
+struct ipu4_camera_module_data {
+	struct list_head list;
+	struct ipu_isys_csi2_config csi2;
+	unsigned int ext_clk;
+	void *pdata; /* Ptr to generated platform data*/
+	void *priv; /* Private for specific subdevice */
+};
+
+struct ipu4_i2c_info {
+	unsigned short bus;
+	unsigned short addr;
+};
+
+struct ipu4_acpi_devices {
+	const char *hid_name;
+	const char *real_driver;
+	int (*get_platform_data)(struct i2c_client *client,
+				 struct ipu4_camera_module_data *data,
+				 struct ipu4_i2c_helper *helper,
+				 void *priv, size_t size);
+	void *priv_data;
+	size_t priv_size;
+	const struct ipu_regulator *regulators;
+};
+
+static uint64_t imx132_op_clocks[] = (uint64_t []){ 312000000, 0 };
+
+/*
+ * Add a request to create new i2c devices later on. i2c_new_device can't be
+ * directly called from functions which are called by i2c_for_each_dev
+ * function. Both takes a same mutex inside i2c core code.
+ */
+static int add_new_i2c(unsigned short addr, unsigned short  bus,
+		       unsigned short flags, char *name, void *pdata)
+{
+	struct ipu4_i2c_new_dev *newdev = kzalloc(sizeof(*newdev), GFP_KERNEL);
+
+	if (!newdev)
+		return -ENOMEM;
+
+	newdev->info.flags = flags;
+	newdev->info.addr = addr;
+	newdev->bus = bus;
+	newdev->info.platform_data = pdata;
+	strlcpy(newdev->info.type, name, sizeof(newdev->info.type));
+
+	list_add(&newdev->list, &new_devs);
+	return 0;
+}
+
+static int get_string_dsdt_data(struct device *dev, const u8 *dsdt,
+				int func, char *out, unsigned int size)
+{
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	union acpi_object *obj;
+	int ret = -ENODEV;
+
+	obj = acpi_evaluate_dsm(dev_handle, (void *)dsdt, 0, func, NULL);
+	if (!obj) {
+		dev_err(dev, "No dsdt field\n");
+		return -ENODEV;
+	}
+	dev_dbg(dev, "ACPI type %d", obj->type);
+
+	if ((obj->type != ACPI_TYPE_STRING) || !obj->string.pointer)
+		goto exit;
+
+	strlcpy(out, obj->string.pointer,
+		min((unsigned int)(obj->string.length + 1), size));
+	dev_info(dev, "DSDT string id: %s\n", out);
+
+	ret = 0;
+exit:
+	ACPI_FREE(obj);
+	return ret;
+}
+
+static int get_integer_dsdt_data(struct device *dev, const u8 *dsdt,
+				 int func, u64 *out)
+{
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	union acpi_object *obj;
+
+	obj = acpi_evaluate_dsm(dev_handle, (void *)dsdt, 0, func, NULL);
+	if (!obj) {
+		dev_err(dev, "No dsdt\n");
+		return -ENODEV;
+	}
+	dev_dbg(dev, "ACPI type %d", obj->type);
+
+	if (obj->type != ACPI_TYPE_INTEGER) {
+		ACPI_FREE(obj);
+		return -ENODEV;
+	}
+	*out = obj->integer.value;
+	ACPI_FREE(obj);
+	return 0;
+}
+
+static int read_acpi_block(struct device *dev, char *id, void *data, u32 size)
+{
+	union acpi_object *obj;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	int status;
+	u32 buffer_length;
+
+	status = acpi_evaluate_object(dev_handle, id, NULL, &buffer);
+	if (!ACPI_SUCCESS(status))
+		return -ENODEV;
+
+	obj = (union acpi_object *)buffer.pointer;
+	if (!obj || obj->type != ACPI_TYPE_BUFFER) {
+		dev_err(dev, "Could't read acpi buffer\n");
+		status = -ENODEV;
+		goto err;
+	}
+
+	if (obj->buffer.length > size) {
+		dev_err(dev, "Given buffer is too small\n");
+		status = -ENODEV;
+		goto err;
+	}
+
+	memcpy(data, obj->buffer.pointer, min(size, obj->buffer.length));
+	buffer_length = obj->buffer.length;
+	kfree(buffer.pointer);
+
+	return buffer_length;
+err:
+	kfree(buffer.pointer);
+	return status;
+}
+
+static struct ipu4_camera_module_data *add_device_to_list(
+	struct list_head *devices)
+{
+	struct ipu4_camera_module_data *cam_device;
+
+	cam_device = kzalloc(sizeof(*cam_device), GFP_KERNEL);
+	if (!cam_device)
+		return NULL;
+
+	list_add(&cam_device->list, devices);
+	return cam_device;
+}
+
+static int get_sensor_gpio(struct device *dev, int index)
+{
+	struct gpio_desc *gpiod_gpio;
+	int gpio;
+
+	gpiod_gpio = gpiod_get_index(dev, NULL, index, GPIOD_ASIS);
+	if (IS_ERR(gpiod_gpio)) {
+		dev_err(dev, "No gpio from index %d\n", index);
+		return -ENODEV;
+	}
+	gpio = desc_to_gpio(gpiod_gpio);
+	gpiod_put(gpiod_gpio);
+	return gpio;
+}
+
+static void *get_dsdt_vcm(struct device *dev, char *vcm, char *second)
+{
+	void *pdata = NULL;
+	const u8 dsdt_cam_vcm[] = {
+		0x39, 0xA6, 0xC9, 0x75, 0x8A, 0x5C, 0x00, 0x4A,
+		0x9F, 0x48, 0xA9, 0xC3, 0xB5, 0xDA, 0x78, 0x9F };
+	int ret = get_string_dsdt_data(dev, dsdt_cam_vcm, 0,
+				       vcm, VCM_BUFFER_SIZE);
+	if (ret < 0) {
+		dev_err(dev, "get vcm failed - using override: %s\n", second);
+		strlcpy(vcm, second, VCM_BUFFER_SIZE);
+	}
+	dev_dbg(dev, "vcm: %s\n", vcm);
+
+	if (!strcasecmp(vcm, LC898122_NAME)) {
+		struct lc898122_platform_data *lc_pdata;
+
+		dev_dbg(dev, "Setting up voice coil motor lc898821");
+		lc_pdata = kzalloc(sizeof(struct lc898122_platform_data),
+				   GFP_KERNEL);
+		if (lc_pdata)
+			lc_pdata->sensor_device = dev;
+		pdata = lc_pdata;
+		strlcpy(vcm, LC898122_NAME, VCM_BUFFER_SIZE);
+	} else if (!strcasecmp(vcm, DW9714_NAME)) {
+		struct dw9714_platform_data *dw_pdata;
+
+		dev_dbg(dev, "Setting up voice coil motor dw9714");
+		dw_pdata = kzalloc(sizeof(struct dw9714_platform_data),
+				   GFP_KERNEL);
+		if (dw_pdata) {
+			dw_pdata->sensor_dev = dev;
+			if (gpiod_count(dev, NULL) > 1)
+				dw_pdata->gpio_xsd = get_sensor_gpio(dev, 1);
+			else
+				dw_pdata->gpio_xsd = -ENODEV;
+		}
+		pdata = dw_pdata;
+		strlcpy(vcm, DW9714_NAME, VCM_BUFFER_SIZE);
+	}
+	return pdata;
+}
+
+static int get_i2c_info(struct device *dev, struct ipu4_i2c_info *i2c, int size)
+{
+	const u8 dsdt_cam_i2c[] = {
+		0x49, 0x75, 0x25, 0x26, 0x71, 0x92, 0xA4, 0x4C,
+		0xBB, 0x43, 0xC4, 0x89, 0x9D, 0x5A, 0x48, 0x81};
+	u64 num_i2c;
+	int i;
+	int rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, 1, &num_i2c);
+
+	if (rval < 0) {
+		dev_err(dev, "Failed to get number of I2C devices\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < num_i2c && i < size; i++) {
+		u64 data;
+
+		rval = get_integer_dsdt_data(dev, dsdt_cam_i2c, i + 2,
+					     &data);
+		if (rval < 0) {
+			dev_err(dev, "No i2c data\n");
+			return -ENODEV;
+		}
+
+		i2c[i].bus = ((data >> 24) & 0xff) - 1;
+		i2c[i].addr = (data >> 8) & 0xff;
+	}
+	return num_i2c;
+}
+
+static int match_depend(struct device *dev, const void *data)
+{
+	return (dev && dev->fwnode == data) ? 1 : 0;
+}
+
+#define MAX_CONSUMERS 1
+struct ipu4_gpio_regulator_data {
+    struct regulator_desc desc;
+    struct regulator_dev *dev;
+};
+
+struct ipu4_gpio_regulator {
+	struct regulator_consumer_supply consumers[MAX_CONSUMERS];
+	struct regulator_init_data init_data;
+	struct fixed_voltage_config config;
+    struct ipu4_gpio_regulator_data drvdata;
+	struct platform_device pdev;
+	struct list_head list;
+};
+static LIST_HEAD(ipu4_gpio_regulator_head);
+
+static const struct regulator_ops ipu_regulator_ops = {};
+
+static int create_gpio_regulator(struct device *dev, int index, const char *name)
+{
+    struct regulator_config cfg = { };
+	struct ipu4_gpio_regulator *reg_device;
+	struct platform_device *cam_regs[1];
+	struct gpio_desc *gpiod_gpio;
+	int num_consumers = 0;
+
+	gpiod_gpio = gpiod_get_index(dev, NULL, index, GPIOD_OUT_HIGH | GPIOD_FLAGS_BIT_NONEXCLUSIVE);
+	if (IS_ERR(gpiod_gpio)) {
+		dev_err(dev, "No gpio from index %d\n", index);
+		return -ENODEV;
+	}
+
+	reg_device = kzalloc(sizeof(*reg_device), GFP_KERNEL);
+	if (!reg_device)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&reg_device->list);
+	reg_device->consumers[num_consumers].supply = "VANA";
+	reg_device->consumers[num_consumers].dev_name = name;
+	num_consumers++;
+
+	reg_device->init_data.constraints.input_uV	 = 3300000;
+	reg_device->init_data.constraints.min_uV	 = 2800000;
+	reg_device->init_data.constraints.max_uV	 = 2800000;
+	reg_device->init_data.constraints.valid_ops_mask =
+		REGULATOR_CHANGE_STATUS;
+	reg_device->init_data.num_consumer_supplies  = num_consumers;
+	reg_device->init_data.consumer_supplies	     = reg_device->consumers;
+
+	reg_device->drvdata.desc.name = dev_name(dev);
+	//reg_device->info.enable_gpio = gpio;
+    //reg_device->info.enable_high = 1;
+	//reg_device->info.enabled_at_boot = 1;
+	reg_device->drvdata.desc.type = REGULATOR_VOLTAGE;
+    reg_device->drvdata.desc.owner = THIS_MODULE;
+    reg_device->drvdata.desc.ops = &ipu_regulator_ops;
+    reg_device->drvdata.desc.enable_time = 0;
+    reg_device->drvdata.desc.off_on_delay = 0;
+    reg_device->drvdata.desc.fixed_uV = 2800000;
+	//reg_device->info.init_data = &reg_device->init_data;
+	reg_device->pdev.name = "gpio-regulator";
+	reg_device->pdev.id = -1;
+	reg_device->pdev.dev.platform_data = &reg_device->drvdata;
+	cam_regs[0] = &reg_device->pdev;
+
+    cfg.ena_gpiod = gpiod_gpio;
+    cfg.dev = dev;
+    cfg.init_data = &reg_device->init_data;
+    cfg.driver_data = &reg_device->drvdata;
+
+    reg_device->drvdata.dev = devm_regulator_register(&reg_device->pdev.dev, &reg_device->drvdata.desc, &cfg);
+	if (IS_ERR(reg_device->drvdata.dev)) {
+		dev_err(dev, "Failed to register regulator %ld\n", PTR_ERR(reg_device->drvdata.dev));
+		return -ENODEV;
+	}
+
+    platform_set_drvdata(&reg_device->pdev, &reg_device->drvdata);
+
+	platform_add_devices(cam_regs, 1);
+	list_add_tail(&reg_device->list, &ipu4_gpio_regulator_head);
+
+	return 0;
+}
+
+static int remove_gpio_regulator(void)
+{
+	struct ipu4_gpio_regulator *reg_device;
+
+	while (!list_empty(&ipu4_gpio_regulator_head)) {
+		reg_device = list_first_entry(&ipu4_gpio_regulator_head,
+					struct ipu4_gpio_regulator, list);
+		list_del(&reg_device->list);
+
+		platform_device_unregister(&reg_device->pdev);
+		kfree(reg_device);
+	}
+
+	return 0;
+}
+
+static int get_acpi_dep_data(struct device *dev,
+			     struct sensor_bios_data *sensor)
+{
+	struct acpi_handle *dev_handle = ACPI_HANDLE(dev);
+	struct acpi_handle_list dep_devices;
+	acpi_status status;
+	int i;
+
+	if (!acpi_has_method(dev_handle, "_DEP"))
+		return 0;
+
+	status = acpi_evaluate_reference(dev_handle, "_DEP", NULL,
+					 &dep_devices);
+	if (ACPI_FAILURE(status)) {
+		dev_dbg(dev, "Failed to evaluate _DEP.\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < dep_devices.count; i++) {
+		struct acpi_device *device;
+		struct acpi_device_info *info;
+		struct device *p_dev;
+		int match;
+
+		status = acpi_get_object_info(dep_devices.handles[i], &info);
+		if (ACPI_FAILURE(status)) {
+			dev_dbg(dev, "Error reading _DEP device info\n");
+			continue;
+		}
+
+		match = info->valid & ACPI_VALID_HID &&
+			!strcmp(info->hardware_id.string, "INT3472");
+
+		kfree(info);
+
+		if (!match)
+			continue;
+
+		/* Process device IN3472 created by acpi */
+		if (acpi_bus_get_device(dep_devices.handles[i], &device))
+			return -ENODEV;
+
+		dev_dbg(dev, "Depend ACPI device found: %s\n",
+			dev_name(&device->dev));
+
+		p_dev = bus_find_device(&platform_bus_type, NULL,
+					&device->fwnode, match_depend);
+		if (p_dev) {
+			dev_dbg(dev, "Dependent platform device found %s\n",
+				dev_name(p_dev));
+			sensor->dev = p_dev;
+			/* GPIO in index 1 is fixed regulator */
+			create_gpio_regulator(p_dev, 1, dev_name(dev));
+		}
+	}
+	return 0;
+}
+
+static int get_acpi_ssdb_sensor_data(struct device *dev,
+				     struct sensor_bios_data *sensor)
+{
+	struct sensor_bios_data_packed sensor_data;
+	int ret = read_acpi_block(dev, "SSDB", &sensor_data,
+				  sizeof(sensor_data));
+	if (ret < 0)
+		return ret;
+
+	get_acpi_dep_data(dev, sensor);
+
+	/* Xshutdown is not part of the ssdb data */
+	sensor->link = sensor_data.link;
+	sensor->lanes = sensor_data.lanes;
+	sensor->mclkport = sensor_data.mclkport;
+	sensor->flash = sensor_data.flash;
+	sensor->mclkspeed = sensor_data.mclkspeed;
+	dev_dbg(dev, "sensor acpi data: link %d, lanes %d, mclk %d, flash %d, mclkspeed %d\n",
+		sensor->link, sensor->lanes, sensor->mclkport, sensor->flash, sensor->mclkspeed);
+	return 0;
+}
+
+static int ipu_acpi_get_sensor_data(struct device *dev,
+					   struct ipu4_camera_module_data *data,
+					   struct sensor_bios_data *sensor)
+{
+	const u8 mipi_port_dsdt[] = {
+		0xD8, 0x7B, 0x3B, 0xEA, 0x9B, 0xE0, 0x39, 0x42,
+		0xAD, 0x6E, 0xED, 0x52, 0x5F, 0x3F, 0x26, 0xAB };
+	const u8 mclk_out_dsdt[] = {
+		0x51, 0x26, 0xBE, 0x8D, 0xC1, 0x70, 0x6F, 0x4C,
+		0xAC, 0x87, 0xA3, 0x7C, 0xB4, 0x6E, 0x4A, 0xF6 };
+
+	int rval;
+	u64 acpi_data;
+
+	if (sensor) {
+		/* Sensor data from ssdb block */
+		data->csi2.port = sensor->link;
+		data->csi2.nlanes = sensor->lanes;
+		acpi_data = sensor->mclkport;
+		data->ext_clk = sensor->mclkspeed;
+	} else {
+		rval = get_integer_dsdt_data(dev, mipi_port_dsdt, 0,
+					     &acpi_data);
+		if (rval < 0) {
+			dev_err(dev, "Can't get mipi port\n");
+			return rval;
+		}
+		data->csi2.port = acpi_data & 0xf;
+		data->csi2.nlanes = (acpi_data & 0xf0) >> 4;
+
+		rval = get_integer_dsdt_data(dev, mclk_out_dsdt, 0, &acpi_data);
+		if (rval < 0) {
+			dev_err(dev, "Can't get mclk info\n");
+			return rval;
+		}
+		/* we have 24 MHz clock for sensors now */
+		data->ext_clk = 286363636;
+	}
+
+	/* dsdt data currently contains wrong numbers for combo ports */
+	if (data->csi2.port >= 6)
+		data->csi2.port -= 2;
+
+	if (data->csi2.nlanes == 0)
+		return -ENODEV;
+
+	switch (acpi_data) {
+	case 0:
+		clk_add_alias(NULL, dev_name(dev), "ipu4_cam_clk0", NULL);
+		break;
+	case 1:
+		clk_add_alias(NULL, dev_name(dev), "ipu4_cam_clk1", NULL);
+		break;
+	case 2:
+		clk_add_alias(NULL, dev_name(dev), "ipu4_cam_clk2", NULL);
+		break;
+	default:
+		dev_err(dev, "Unknown clk data %u\n", (unsigned int)acpi_data);
+		break;
+	}
+
+	dev_dbg(dev, "sensor: lanes %d, port %d, clk out %d, ext_clk %d\n",
+		data->csi2.nlanes,
+		data->csi2.port, (int)acpi_data, data->ext_clk);
+	return 0;
+}
+
+static int get_custom_gpios(struct device *dev,
+			    struct crlmodule_platform_data *pdata)
+{
+	int i, ret, c = gpiod_count(dev, NULL) - 1;
+
+	for (i = 0; i < c; i++) {
+		ret = snprintf(pdata->custom_gpio[i].name,
+			       sizeof(pdata->custom_gpio[i].name),
+			       "custom_gpio%d", i);
+		if (ret < 0 || ret >=  sizeof(pdata->custom_gpio[i].name)) {
+			dev_err(dev, "Failed to set custom gpio name\n");
+			return -EINVAL;
+		}
+		/* First GPIO is xshutdown */
+		pdata->custom_gpio[i].number = get_sensor_gpio(dev, i + 1);
+		if (pdata->custom_gpio[i].number < 0) {
+			dev_err(dev, "unable to get custom gpio number\n");
+			return -ENODEV;
+		}
+		pdata->custom_gpio[i].val = 1;
+		pdata->custom_gpio[i].undo_val = 0;
+	}
+
+	return 0;
+}
+
+static int get_crlmodule_pdata(struct i2c_client *client,
+			       struct ipu4_camera_module_data *data,
+			       struct ipu4_i2c_helper *helper,
+			       void *priv, size_t size)
+{
+	struct sensor_bios_data sensor;
+	struct crlmodule_platform_data *pdata;
+	struct ipu4_i2c_info i2c[2];
+	void *vcm_pdata;
+	char vcm[VCM_BUFFER_SIZE];
+	int num = get_i2c_info(&client->dev, i2c, ARRAY_SIZE(i2c));
+	int rval;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	sensor.dev = &client->dev;
+
+	rval = get_acpi_ssdb_sensor_data(&client->dev, &sensor);
+
+	ipu_acpi_get_sensor_data(&client->dev, data,
+					rval == 0 ? &sensor : NULL);
+
+	data->pdata = pdata;
+	/* sensor.dev may here point to sensor or dependent device */
+	pdata->xshutdown = get_sensor_gpio(sensor.dev, 0);
+	if (pdata->xshutdown < 0) {
+		rval = pdata->xshutdown;
+		goto err_free_pdata;
+	}
+
+	rval = get_custom_gpios(sensor.dev, pdata);
+	if (rval)
+		goto err_free_pdata;
+
+	pdata->lanes = data->csi2.nlanes;
+	pdata->ext_clk = data->ext_clk;
+	client->dev.platform_data = pdata;
+
+	helper->fn(&client->dev, helper->driver_data, &data->csi2, true);
+
+	if ((num <= 1) || !priv)
+		return 0;
+
+	vcm_pdata = get_dsdt_vcm(&client->dev, vcm, priv);
+
+	dev_info(&client->dev, "Creating vcm instance: bus: %d addr 0x%x %s\n",
+		 i2c[1].bus, i2c[1].addr, vcm);
+
+	return add_new_i2c(i2c[1].addr, i2c[1].bus, 0, vcm, vcm_pdata);
+
+err_free_pdata:
+	kfree(pdata);
+	data->pdata = NULL;
+	return rval;
+}
+
+static int get_smiapp_pdata(struct i2c_client *client,
+			    struct ipu4_camera_module_data *data,
+			    struct ipu4_i2c_helper *helper,
+			    void *priv, size_t size)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	struct smiapp_platform_data *pdata;
+#elseif LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
+	struct smiapp_hwconfig *pdata;
+#else
+    struct ccs_hwconfig *pdata;
+#endif
+	uint64_t *source = priv;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+	data->pdata = pdata;
+
+	data->priv = source;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	pdata->xshutdown = get_sensor_gpio(&client->dev, 0);
+	if (pdata->xshutdown < 0)
+		return -ENODEV;
+#endif
+
+	ipu_acpi_get_sensor_data(&client->dev, data, NULL);
+
+	pdata->op_sys_clock = source;
+	pdata->lanes = data->csi2.nlanes;
+	pdata->ext_clk = data->ext_clk;
+
+	client->dev.platform_data = pdata;
+	helper->fn(&client->dev, helper->driver_data, &data->csi2, true);
+
+	return 0;
+}
+
+static int get_lm3643_pdata(struct i2c_client *client,
+			    struct ipu4_camera_module_data *data,
+			    struct ipu4_i2c_helper *helper,
+			    void *priv, size_t size)
+{
+	struct lm3643_platform_data *pdata;
+	struct ipu4_i2c_info i2c[2];
+	struct gpio_desc *gpiod_reset;
+	int i;
+	int num = get_i2c_info(&client->dev, i2c, ARRAY_SIZE(i2c));
+
+	if (num < 0)
+		return -ENODEV;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	gpiod_reset = gpiod_get_index(&client->dev, NULL, 0, GPIOD_ASIS);
+	if (IS_ERR(gpiod_reset)) {
+		pdata->gpio_reset = -1;
+		dev_info(&client->dev, "No reset for lm3643\n");
+	} else {
+		pdata->gpio_reset = desc_to_gpio(gpiod_reset);
+		gpiod_put(gpiod_reset);
+	}
+
+	/* These should be added to ACPI */
+	data->pdata = pdata;
+	pdata->gpio_torch = -1;
+	pdata->gpio_strobe = -1;
+	pdata->flash_max_brightness = 500;
+	pdata->torch_max_brightness = 89;
+
+	client->dev.platform_data = pdata;
+	helper->fn(&client->dev, helper->driver_data, NULL, true);
+
+	/*
+	 * Same I2C ACPI entry may contain several instances. I2C core
+	 * ACPI code creates only the first one. Create rest of the instances
+	 */
+	dev_info(&client->dev, "Adding rest of lm3643 instances: %d\n", num);
+	for (i = 1; i < num; i++) {
+		int rval = add_new_i2c(i2c[i].addr, i2c[i].bus,
+				       0, client->name, pdata);
+		if (rval < 0)
+			return rval;
+		dev_info(&client->dev, "LM3643 instance: bus: %d addr 0x%x\n",
+			 i2c[i].bus, i2c[i].addr);
+		return -ENOMEM;
+	}
+
+	return 0;
+};
+
+static int get_as3638_pdata(struct i2c_client *client,
+			    struct ipu4_camera_module_data *data,
+			    struct ipu4_i2c_helper *helper,
+			    void *priv, size_t size)
+{
+	struct as3638_platform_data *pdata;
+	struct gpio_desc *gpiod_pin;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	gpiod_pin = gpiod_get_index(&client->dev, NULL, 0, GPIOD_ASIS);
+	if (IS_ERR(gpiod_pin)) {
+		pdata->gpio_reset = -1;
+		dev_info(&client->dev, "No reset gpio for as3638\n");
+	} else {
+		pdata->gpio_reset = desc_to_gpio(gpiod_pin);
+		gpiod_put(gpiod_pin);
+	}
+
+	gpiod_pin = gpiod_get_index(&client->dev, NULL, 1, GPIOD_ASIS);
+	if (IS_ERR(gpiod_pin)) {
+		pdata->gpio_torch = -1;
+		dev_info(&client->dev, "No torch gpio for as3638\n");
+	} else {
+		pdata->gpio_torch = desc_to_gpio(gpiod_pin);
+		gpiod_put(gpiod_pin);
+	}
+
+	gpiod_pin = gpiod_get_index(&client->dev, NULL, 2, GPIOD_ASIS);
+	if (IS_ERR(gpiod_pin)) {
+		pdata->gpio_strobe = -1;
+		dev_info(&client->dev, "No strobe gpio for as3638\n");
+	} else {
+		pdata->gpio_strobe = desc_to_gpio(gpiod_pin);
+		gpiod_put(gpiod_pin);
+	}
+
+	/* These should be added to ACPI */
+	data->pdata = pdata;
+	pdata->flash_max_brightness[AS3638_LED1] =
+		AS3638_FLASH_MAX_BRIGHTNESS_LED1;
+	pdata->torch_max_brightness[AS3638_LED1] =
+		AS3638_TORCH_MAX_BRIGHTNESS_LED1;
+	pdata->flash_max_brightness[AS3638_LED2] =
+		AS3638_FLASH_MAX_BRIGHTNESS_LED2;
+	pdata->torch_max_brightness[AS3638_LED2] =
+		AS3638_TORCH_MAX_BRIGHTNESS_LED2;
+	pdata->flash_max_brightness[AS3638_LED3] =
+		AS3638_FLASH_MAX_BRIGHTNESS_LED3;
+	pdata->torch_max_brightness[AS3638_LED3] =
+		AS3638_TORCH_MAX_BRIGHTNESS_LED3;
+
+	client->dev.platform_data = pdata;
+	helper->fn(&client->dev, helper->driver_data, NULL, true);
+
+	return 0;
+};
+
+static const struct ipu4_acpi_devices supported_devices[] = {
+	{ "SONY230A", CRLMODULE_NAME, get_crlmodule_pdata, LC898122_NAME, 0,
+	  imx230regulators },
+	{ "INT3477",  CRLMODULE_NAME, get_crlmodule_pdata, NULL, 0,
+	  ov8858regulators },
+	{ "INT3471",  CRLMODULE_NAME, get_crlmodule_pdata, NULL, 0 },
+	{ "OV5670AA",  CRLMODULE_NAME, get_crlmodule_pdata, NULL, 0 },
+	{ "SONY214A", CRLMODULE_NAME, get_crlmodule_pdata, "dw9714", 0 },
+	{ "SONY132A", SMIAPP_NAME,    get_smiapp_pdata, imx132_op_clocks,
+	  sizeof(imx132_op_clocks) },
+	{ "TXNW3643", LM3643_NAME,    get_lm3643_pdata, NULL, 0 },
+	{ "AMS3638", AS3638_NAME,    get_as3638_pdata, NULL, 0 },
+	{ "ADV7481A", CRLMODULE_NAME, get_crlmodule_pdata, NULL, 0 },
+	{ "ADV7481B", CRLMODULE_NAME, get_crlmodule_pdata, NULL, 0 },
+};
+
+static int get_table_index(struct device *device, const __u8 *acpi_name)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(supported_devices); i++) {
+		if (!strcmp(acpi_name, supported_devices[i].hid_name))
+			return i;
+	}
+
+	return -ENODEV;
+}
+
+/* List of ACPI devices what we can handle */
+static const struct acpi_device_id ipu4_acpi_match[] = {
+	{ "SONY230A", 0 },
+	{ "INT3477",  0 },
+	{ "INT3471",  0 },
+	{ "TXNW3643", 0 },
+	{ "AMS3638", 0 },
+	{ "SONY214A", 0 },
+	{ "SONY132A", 0 },
+	{ "OV5670AA", 0 },
+	{ "ADV7481A", 0 },
+	{ "ADV7481B", 0 },
+	{},
+};
+
+static int map_power_rails(char *src_dev_name, char *src_regulator,
+			   struct device *dev, char *dest_rail)
+{
+	struct device *src_dev;
+	int rval;
+
+	if (!src_dev_name) {
+		dev_dbg(dev, "Regulator device name missing");
+		return -ENODEV;
+	}
+
+	src_dev = bus_find_device_by_name(&platform_bus_type, NULL,
+					  src_dev_name);
+	if (!src_dev) {
+		dev_dbg(dev, "Regulator device not found");
+		return -ENODEV;
+	}
+
+	rval = regulator_register_supply_alias(dev, dest_rail, src_dev,
+					       src_regulator);
+	if (rval < 0) {
+		dev_err(dev, "Regulator alias mapping fails %s, %s <-> %s, %s",
+			dev_name(src_dev), src_regulator,
+			dev_name(dev), dest_rail);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int ipu_acpi_pdata(struct i2c_client *client,
+				 const struct acpi_device_id *acpi_id,
+				 struct ipu4_i2c_helper *helper)
+{
+	struct ipu4_camera_module_data *camdata;
+	const struct ipu_regulator *regulators;
+	int index = get_table_index(&client->dev, acpi_id->id);
+
+	if (index < 0) {
+		dev_err(&client->dev,
+			"Device is not in supported devices list\n");
+		return -ENODEV;
+	}
+
+	camdata = add_device_to_list(&devices);
+	if (!camdata)
+		return -ENOMEM;
+
+	strlcpy(client->name, supported_devices[index].real_driver,
+		sizeof(client->name));
+
+	regulators = supported_devices[index].regulators;
+	while (regulators && regulators->src_dev_name) {
+		map_power_rails(regulators->src_dev_name,
+				regulators->src_rail,
+				&client->dev,
+				regulators->dest_rail);
+		regulators++;
+	}
+
+	supported_devices[index].get_platform_data(
+		client, camdata, helper,
+		supported_devices[index].priv_data,
+		supported_devices[index].priv_size);
+
+	return 0;
+}
+
+static int ipu4_i2c_test(struct device *dev, void *priv)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
+	const struct acpi_device_id *acpi_id;
+
+	/*
+	 * Check that we are handling only I2C devices which really has
+	 * ACPI data and are one of the devices which we want to handle
+	 */
+	if (!ACPI_COMPANION(dev) || !client)
+		return 0;
+
+	acpi_id = acpi_match_device(ipu4_acpi_match, dev);
+	if (!acpi_id)
+		return 0;
+
+	/*
+	 * Skip if platform data has already been added.
+	 * Probably ACPI data overruled by kernel platform data
+	 */
+	if (client->dev.platform_data) {
+		dev_info(dev, "ACPI device has already platform data\n");
+		return 0;
+	}
+
+	/* Looks that we got what we are looking for */
+	if (ipu_acpi_pdata(client, acpi_id, priv))
+		dev_err(dev, "Failed to process ACPI data");
+
+	/* Don't return error since we want to process remaining devices */
+	return 0;
+}
+
+/* Scan all i2c devices and pick ones which we can handle */
+int ipu_get_acpi_devices(void *driver_data,
+				struct device *dev,
+				int (*fn)
+				(struct device *, void *,
+				 struct ipu_isys_csi2_config *csi2,
+				 bool reprobe))
+{
+	struct ipu4_i2c_helper helper = {
+		.fn = fn,
+		.driver_data = driver_data,
+	};
+	struct ipu4_i2c_new_dev *new_i2c_dev, *safe;
+	int rval;
+
+	if ((!fn) || (!driver_data))
+		return -ENODEV;
+
+	rval = i2c_for_each_dev(&helper, ipu4_i2c_test);
+	if (rval < 0)
+		return rval;
+
+	/*
+	 * Some ACPI entries may contain several i2c devices.
+	 * Create new devices here if those were added to list during
+	 * ACPI processing
+	 */
+	list_for_each_entry_safe(new_i2c_dev, safe, &new_devs, list) {
+		struct i2c_adapter *adapter;
+		struct i2c_client *client;
+
+		adapter = i2c_get_adapter(new_i2c_dev->bus);
+		if (!adapter) {
+			dev_err(dev, "Failed to get adapter\n");
+			list_del(&new_i2c_dev->list);
+			kfree(new_i2c_dev);
+			continue;
+		}
+
+		dev_info(dev, "New i2c device: %s\n", new_i2c_dev->info.type);
+		request_module(I2C_MODULE_PREFIX "%s", new_i2c_dev->info.type);
+
+		client = i2c_new_client_device(adapter, &new_i2c_dev->info);
+		if (client)
+			fn(&client->dev, driver_data, NULL, false);
+		else
+			dev_err(dev, "failed to add I2C device from ACPI\n");
+
+		i2c_put_adapter(adapter);
+		list_del(&new_i2c_dev->list);
+		kfree(new_i2c_dev);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ipu_get_acpi_devices);
+
+static void __exit ipu_acpi_exit(void)
+{
+	remove_gpio_regulator();
+}
+module_exit(ipu_acpi_exit);
+
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("IPU4 ACPI support");
diff --git a/drivers/media/platform/intel/ipu4-bxt-gp-pdata.c b/drivers/media/platform/intel/ipu4-bxt-gp-pdata.c
new file mode 100644
index 000000000000..9acfafc9cf42
--- /dev/null
+++ b/drivers/media/platform/intel/ipu4-bxt-gp-pdata.c
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2016--2017 Intel Corporation.
+ *
+ * Author: Jouni Ukkonen <jouni.ukkonen@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <media/ipu-isys.h>
+#include <media/crlmodule.h>
+#include "ipu.h"
+
+#define ADV7481_HDMI_LANES      4
+#define ADV7481_HDMI_I2C_ADDRESS 0xe0
+
+#define ADV7481_LANES		1
+/*
+ * below i2c address is dummy one, to be able to register single
+ * ADV7481 chip as two sensors
+ */
+#define ADV7481_I2C_ADDRESS	0xe1
+
+
+#define GPIO_BASE		434
+
+
+static struct crlmodule_platform_data adv7481_cvbs_pdata = {
+	.ext_clk = 286363636,
+	.xshutdown = GPIO_BASE + 64, /*dummy for now*/
+	.lanes = ADV7481_LANES,
+	.module_name = "ADV7481 CVBS",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_cvbs_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info adv7481_cvbs_crl_sd = {
+	.csi2 = &adv7481_cvbs_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_I2C_ADDRESS,
+			 .platform_data = &adv7481_cvbs_pdata,
+		},
+		.i2c_adapter_id = 0,
+	}
+};
+
+static struct crlmodule_platform_data adv7481_hdmi_pdata = {
+	/* FIXME: may need to revisit */
+	.ext_clk = 286363636,
+	.xshutdown = GPIO_BASE + 30,
+	.lanes = ADV7481_HDMI_LANES,
+	.module_name = "ADV7481 HDMI",
+	.crl_irq_pin = GPIO_BASE + 22,
+	.irq_pin_flags = (IRQF_TRIGGER_RISING | IRQF_ONESHOT),
+	.irq_pin_name = "ADV7481_HDMI_IRQ",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_hdmi_csi2_cfg = {
+	.nlanes = ADV7481_HDMI_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info adv7481_hdmi_crl_sd = {
+	.csi2 = &adv7481_hdmi_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_HDMI_I2C_ADDRESS,
+			 .platform_data = &adv7481_hdmi_pdata,
+		},
+		.i2c_adapter_id = 0,
+	}
+};
+
+
+
+/*
+ * Map buttress output sensor clocks to sensors -
+ * this should be coming from ACPI, in Gordon Peak
+ * ADV7481 have its own oscillator, no buttres clock
+ * needed.
+ */
+struct ipu_isys_clk_mapping gp_mapping[] = {
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+		&adv7481_hdmi_crl_sd,
+		&adv7481_cvbs_crl_sd,
+		NULL,
+	},
+	.clk_map = gp_mapping,
+};
+
+static void ipu4_quirk(struct pci_dev *pci_dev)
+{
+	pci_dev->dev.platform_data = &pdata;
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU_PCI_ID,
+			ipu4_quirk);
diff --git a/drivers/media/platform/intel/ipu4-bxt-p-pdata.c b/drivers/media/platform/intel/ipu4-bxt-p-pdata.c
new file mode 100644
index 000000000000..699a89b78ab2
--- /dev/null
+++ b/drivers/media/platform/intel/ipu4-bxt-p-pdata.c
@@ -0,0 +1,1708 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2015 - 2018 Intel Corporation
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <media/ipu-isys.h>
+#include <media/crlmodule.h>
+#include <media/ti964.h>
+#include <media/ti960.h>
+#include <media/max9286.h>
+#include "ipu.h"
+
+#define GPIO_BASE		934
+
+#ifdef CONFIG_INTEL_IPU4_OV2740
+#define OV2740_LANES		2
+#define OV2740_I2C_ADDRESS	0x36
+static struct crlmodule_platform_data ov2740_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = OV2740_LANES,
+	.ext_clk = 19200000,
+	.op_sys_clock = (uint64_t []){ 72000000 },
+	.module_name = "INT3474",
+	.id_string = "0x27 0x40",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ov2740_csi2_cfg = {
+	.nlanes = OV2740_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ov2740_crl_sd = {
+	.csi2 = &ov2740_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, OV2740_I2C_ADDRESS),
+			.platform_data = &ov2740_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX185
+#define IMX185_LANES		4
+#define IMX185_I2C_ADDRESS	0x1a
+
+static struct crlmodule_platform_data imx185_pdata = {
+	.xshutdown = GPIO_BASE + 71,
+	.lanes = IMX185_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){ 55687500, 111375000,
+					111375000, 222750000 },
+	.module_name = "IMX185",
+	.id_string = "0x1 0x85",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx185_csi2_cfg = {
+	.nlanes = IMX185_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx185_crl_sd = {
+	.csi2 = &imx185_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, IMX185_I2C_ADDRESS),
+			.platform_data = &imx185_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data imx185_b_pdata = {
+	.xshutdown = GPIO_BASE + 73,
+	.lanes = IMX185_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){ 55687500, 111375000,
+					111375000, 222750000 },
+	.module_name = "IMX185",
+	.id_string = "0x1 0x85",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config imx185_b_csi2_cfg = {
+	.nlanes = IMX185_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info imx185_b_crl_sd = {
+	.csi2 = &imx185_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, IMX185_I2C_ADDRESS),
+			.platform_data = &imx185_b_pdata,
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_AR023Z
+#define AR023Z_MIPI_LANES	2
+/* Toshiba TC358778 Parallel-MIPI Bridge */
+#define TC358778_I2C_ADDRESS	0x0e
+
+static struct crlmodule_platform_data ar023z_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = AR023Z_MIPI_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){317250000},
+	.module_name = "AR023Z",
+	.id_string = "0x4401 0x64",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ar023z_csi2_cfg = {
+	.nlanes = AR023Z_MIPI_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ar023z_crl_sd = {
+	.csi2 = &ar023z_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, TC358778_I2C_ADDRESS),
+			.platform_data = &ar023z_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data ar023z_b_pdata = {
+	.xshutdown = GPIO_BASE + 67,
+	.lanes = AR023Z_MIPI_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t []){317250000},
+	.module_name = "AR023Z",
+	.id_string = "0x4401 0x64",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config ar023z_b_csi2_cfg = {
+	.nlanes = AR023Z_MIPI_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info ar023z_b_crl_sd = {
+	.csi2 = &ar023z_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, TC358778_I2C_ADDRESS),
+			.platform_data = &ar023z_b_pdata,
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX477
+#define IMX477_LANES	   2
+
+#define IMX477_I2C_ADDRESS 0x10
+
+static struct crlmodule_platform_data imx477_pdata_master = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = IMX477_LANES,
+	.ext_clk = 19200000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "IMX477-MASTER",
+	.id_string = "0x4 0x77",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx477_csi2_cfg_master = {
+	.nlanes = IMX477_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx477_crl_sd_master = {
+	.csi2 = &imx477_csi2_cfg_master,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX477_I2C_ADDRESS),
+			.platform_data = &imx477_pdata_master,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data imx477_pdata_slave_1 = {
+	.xshutdown = GPIO_BASE + 67,
+	.lanes = IMX477_LANES,
+	.ext_clk = 19200000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "IMX477-SLAVE-1",
+	.id_string = "0x4 0x77",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config imx477_csi2_cfg_slave_1 = {
+	.nlanes = IMX477_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info imx477_crl_sd_slave_1 = {
+	.csi2 = &imx477_csi2_cfg_slave_1,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX477_I2C_ADDRESS),
+			.platform_data = &imx477_pdata_slave_1,
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX274
+
+#define IMX274_LANES		4
+#define IMX274_I2C_ADDRESS	0x1a
+
+static struct crlmodule_platform_data imx274_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = IMX274_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){720000000},
+	.module_name = "IMX274",
+	.id_string = "0x6 0x9",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx274_csi2_cfg = {
+	.nlanes = IMX274_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx274_crl_sd = {
+	.csi2 = &imx274_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX274_I2C_ADDRESS),
+			.platform_data = &imx274_pdata
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data imx274_b_pdata = {
+	.xshutdown = GPIO_BASE + 67,
+	.lanes = IMX274_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){720000000},
+	.module_name = "IMX274",
+	.id_string = "0x6 0x9",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config imx274_b_csi2_cfg = {
+	.nlanes = IMX274_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info imx274_b_crl_sd = {
+	.csi2 = &imx274_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX274_I2C_ADDRESS),
+			.platform_data = &imx274_b_pdata
+		},
+		.i2c_adapter_id = 4,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_IMX290
+
+#define IMX290_LANES		4
+#define IMX290_I2C_ADDRESS	0x1a
+
+static struct crlmodule_platform_data imx290_pdata = {
+	.xshutdown = GPIO_BASE + 64,
+	.lanes = IMX290_LANES,
+	.ext_clk = 37125000,
+	.op_sys_clock = (uint64_t []){222750000, 445500000},
+	.module_name = "IMX290",
+	.id_string = "0x2 0x90",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config imx290_csi2_cfg = {
+	.nlanes = IMX290_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info imx290_crl_sd = {
+	.csi2 = &imx290_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(CRLMODULE_NAME, IMX290_I2C_ADDRESS),
+			.platform_data = &imx290_pdata
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV13860
+
+#define OV13860_LANES		2
+#define OV13860_I2C_ADDRESS	0x10
+
+static struct crlmodule_platform_data ov13860_pdata = {
+	.xshutdown = GPIO_BASE + 71,
+	.lanes = OV13860_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 600000000, 300000000},
+	.module_name = "OV13860",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ov13860_csi2_cfg = {
+	.nlanes = OV13860_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ov13860_crl_sd = {
+	.csi2 = &ov13860_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, OV13860_I2C_ADDRESS),
+			 .platform_data = &ov13860_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV9281
+
+#define OV9281_LANES		2
+#define OV9281_I2C_ADDRESS	0x10
+
+static struct crlmodule_platform_data ov9281_pdata = {
+	.xshutdown = GPIO_BASE + 71,
+	.lanes = OV9281_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){400000000},
+	.module_name = "OV9281",
+	.id_string = "0x92 0x81",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config ov9281_csi2_cfg = {
+	.nlanes = OV9281_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info ov9281_crl_sd = {
+	.csi2 = &ov9281_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO(CRLMODULE_NAME, OV9281_I2C_ADDRESS),
+			 .platform_data = &ov9281_pdata,
+		},
+		.i2c_adapter_id = 0,
+	}
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_BU64295)
+
+#define BU64295_VCM_ADDR	0x0c
+#define BU64295_NAME		"bu64295"
+
+static struct ipu_isys_subdev_info bu64295_sd = {
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO(BU64295_NAME,  BU64295_VCM_ADDR),
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_ADV7481
+
+#define ADV7481_LANES		4
+#define ADV7481_I2C_ADDRESS	0xe0
+#define ADV7481B_I2C_ADDRESS	0xe2
+
+static struct crlmodule_platform_data adv7481_pdata = {
+	.xshutdown = GPIO_BASE + 63,
+	.lanes = ADV7481_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "ADV7481",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info adv7481_crl_sd = {
+	.csi2 = &adv7481_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_I2C_ADDRESS,
+			 .platform_data = &adv7481_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_ADV7481_EVAL
+
+#define ADV7481_LANES		4
+#define ADV7481_I2C_ADDRESS	0xe0
+#define ADV7481B_I2C_ADDRESS	0xe2
+
+static struct crlmodule_platform_data adv7481_eval_pdata = {
+	.xshutdown = GPIO_BASE + 63,
+	.lanes = ADV7481_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "ADV7481_EVAL",
+	.suffix = 'a',
+};
+
+static struct ipu_isys_csi2_config adv7481_eval_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info adv7481_eval_crl_sd = {
+	.csi2 = &adv7481_eval_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481_I2C_ADDRESS,
+			 .platform_data = &adv7481_eval_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct crlmodule_platform_data adv7481b_eval_pdata = {
+	.xshutdown = GPIO_BASE + 63,
+	.lanes = ADV7481_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){600000000},
+	.module_name = "ADV7481B_EVAL",
+	.suffix = 'b',
+};
+
+static struct ipu_isys_csi2_config adv7481b_eval_csi2_cfg = {
+	.nlanes = ADV7481_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info adv7481b_eval_crl_sd = {
+	.csi2 = &adv7481b_eval_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = CRLMODULE_NAME,
+			 .flags = I2C_CLIENT_TEN,
+			 .addr = ADV7481B_I2C_ADDRESS,
+			 .platform_data = &adv7481b_eval_pdata,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_AGGREGATOR_STUB)
+
+#define VIDEO_AGGRE_LANES	4
+#define VIDEO_AGGRE_I2C_ADDRESS	0x3b
+#define VIDEO_AGGRE_B_I2C_ADDRESS	0x3c
+
+static struct ipu_isys_csi2_config video_aggre_csi2_cfg = {
+	.nlanes = VIDEO_AGGRE_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_subdev_info video_aggre_stub_sd = {
+	.csi2 = &video_aggre_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "video-aggre",
+			 .addr = VIDEO_AGGRE_I2C_ADDRESS,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+
+static struct ipu_isys_csi2_config video_aggre_b_csi2_cfg = {
+	.nlanes = VIDEO_AGGRE_LANES,
+	.port = 4,
+};
+
+static struct ipu_isys_subdev_info video_aggre_b_stub_sd = {
+	.csi2 = &video_aggre_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "video-aggre",
+			 .addr = VIDEO_AGGRE_B_I2C_ADDRESS,
+		},
+		.i2c_adapter_id = 2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_MAGNA
+#define MAGNA_LANES		4
+#define MAGNA_PHY_ADDR	0x60 /* 0x30 for 7bit addr */
+#define MAGNA_ADDRESS_A	0x61
+#define MAGNA_ADDRESS_B 0x62
+
+static struct crlmodule_platform_data magna_pdata = {
+	.lanes = MAGNA_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 400000000 },
+	.module_name = "MAGNA",
+	.id_string = "0xa6 0x35",
+	/*
+	 * The pin number of xshutdown will be determined
+	 * and replaced inside TI964 driver.
+	 * The number here stands for which GPIO to connect with.
+	 * 1 means to connect sensor xshutdown to GPIO1
+	 */
+	.xshutdown = 1,
+	/*
+	 * this flags indicates the expected polarity for the LineValid
+	 * indication received in Raw mode.
+	 * 1 means LineValid is high for the duration of the video frame.
+	 */
+	.high_framevalid_flags = 1,
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV10635
+#define OV10635_LANES		4
+#define OV10635_I2C_PHY_ADDR	0x60 /* 0x30 for 7bit addr */
+#define OV10635A_I2C_ADDRESS	0x61
+#define OV10635B_I2C_ADDRESS	0x62
+#define OV10635C_I2C_ADDRESS	0x63
+#define OV10635D_I2C_ADDRESS	0x64
+
+static struct crlmodule_platform_data ov10635_pdata = {
+	.lanes = OV10635_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 400000000 },
+	.module_name = "OV10635",
+	.id_string = "0xa6 0x35",
+	/*
+	 * The pin number of xshutdown will be determined
+	 * and replaced inside TI964 driver.
+	 * The number here stands for which GPIO to connect with.
+	 * 1 means to connect sensor xshutdown to GPIO1
+	 */
+	.xshutdown = 0,
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OV10640
+#define OV10640_LANES			4
+#define OV10640_I2C_PHY_ADDR	0x60 /* 0x30 for 7bit addr */
+#define OV10640A_I2C_ADDRESS	0x61
+#define OV10640B_I2C_ADDRESS	0x62
+#define OV10640C_I2C_ADDRESS	0x63
+#define OV10640D_I2C_ADDRESS	0x64
+
+static struct crlmodule_platform_data ov10640_pdata = {
+	.lanes = OV10640_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t []){ 400000000 },
+	.module_name = "OV10640",
+	.id_string = "0xa6 0x40",
+	/*
+	 * The pin number of xshutdown will be determined
+	 * and replaced inside TI964 driver.
+	 * The number here stands for which GPIO to connect with.
+	 * 1 means to connect sensor xshutdown to GPIO1
+	 */
+	.xshutdown = 1,
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_TI964)
+#define TI964_I2C_ADAPTER	0
+#define TI964_I2C_ADAPTER_2	7
+#define TI964_I2C_ADDRESS	0x3d
+#define TI964_LANES		4
+
+static struct ipu_isys_csi2_config ti964_csi2_cfg = {
+	.nlanes = TI964_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_csi2_config ti964_csi2_cfg_2 = {
+	.nlanes = TI964_LANES,
+	.port = 4,
+};
+
+static struct ti964_subdev_info ti964_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_OV10635
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635A_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635B_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635C_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635D_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'd',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV10640
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640A_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640B_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640C_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640D_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'd',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_MAGNA
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = MAGNA_ADDRESS_A,
+			.platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			  .type = CRLMODULE_NAME,
+			  .addr = MAGNA_ADDRESS_B,
+			  .platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'b',
+	},
+#endif
+};
+
+static struct ti964_subdev_info ti964_subdevs_2[] = {
+#ifdef CONFIG_INTEL_IPU4_OV10635
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635A_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635B_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'f',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635C_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'g',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635D_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'h',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV10640
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640A_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640B_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'f',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640C_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'g',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640D_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'h',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_MAGNA
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = MAGNA_ADDRESS_A,
+			.platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			  .type = CRLMODULE_NAME,
+			  .addr = MAGNA_ADDRESS_B,
+			  .platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'f',
+	},
+#endif
+};
+
+static struct ti964_pdata ti964_pdata = {
+	.subdev_info = ti964_subdevs,
+	.subdev_num = ARRAY_SIZE(ti964_subdevs),
+	.reset_gpio = GPIO_BASE + 63,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info ti964_sd = {
+	.csi2 = &ti964_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "ti964",
+			 .addr = TI964_I2C_ADDRESS,
+			 .platform_data = &ti964_pdata,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER,
+	}
+};
+
+static struct ti964_pdata ti964_pdata_2 = {
+	.subdev_info = ti964_subdevs_2,
+	.subdev_num = ARRAY_SIZE(ti964_subdevs_2),
+	.reset_gpio = GPIO_BASE + 66,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info ti964_sd_2 = {
+	.csi2 = &ti964_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			 .type = "ti964",
+			 .addr = TI964_I2C_ADDRESS,
+			 .platform_data = &ti964_pdata_2,
+		},
+		.i2c_adapter_id = TI964_I2C_ADAPTER_2,
+	}
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_TI964) /* for AS_1140 */
+#define AS_1140_TI964_I2C_ADAPTER	2
+#define AS_1140_TI964_I2C_ADAPTER_2	4
+
+static struct ipu_isys_csi2_config as_1140_ti964_csi2_cfg = {
+	.nlanes = TI964_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_csi2_config as_1140_ti964_csi2_cfg_2 = {
+	.nlanes = TI964_LANES,
+	.port = 4,
+};
+
+static struct ti964_subdev_info as_1140_ti964_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_OV10635
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635A_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635B_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635C_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635D_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'd',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV10640
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640A_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640B_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640C_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640D_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'd',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_MAGNA
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = MAGNA_ADDRESS_A,
+			.platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			  .type = CRLMODULE_NAME,
+			  .addr = MAGNA_ADDRESS_B,
+			  .platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'b',
+	},
+#endif
+};
+
+static struct ti964_subdev_info as_1140_ti964_subdevs_2[] = {
+#ifdef CONFIG_INTEL_IPU4_OV10635
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635A_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635B_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'f',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635C_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'g',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10635D_I2C_ADDRESS,
+			.platform_data = &ov10635_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10635_I2C_PHY_ADDR,
+		.suffix = 'h',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV10640
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640A_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640B_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'f',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640C_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 2,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'g',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV10640D_I2C_ADDRESS,
+			.platform_data = &ov10640_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 3,
+		.phy_i2c_addr = OV10640_I2C_PHY_ADDR,
+		.suffix = 'h',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_MAGNA
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = MAGNA_ADDRESS_A,
+			.platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			  .type = CRLMODULE_NAME,
+			  .addr = MAGNA_ADDRESS_B,
+			  .platform_data = &magna_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = MAGNA_PHY_ADDR,
+		.suffix = 'f',
+	},
+#endif
+};
+
+static struct ti964_pdata as_1140_ti964_pdata = {
+	.subdev_info = as_1140_ti964_subdevs,
+	.subdev_num = ARRAY_SIZE(as_1140_ti964_subdevs),
+	.reset_gpio = GPIO_BASE + 62,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info as_1140_ti964_sd = {
+	.csi2 = &as_1140_ti964_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "ti964",
+			 .addr = TI964_I2C_ADDRESS,
+			 .platform_data = &as_1140_ti964_pdata,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER,
+	}
+};
+
+static struct ti964_pdata as_1140_ti964_pdata_2 = {
+	.subdev_info = as_1140_ti964_subdevs_2,
+	.subdev_num = ARRAY_SIZE(as_1140_ti964_subdevs_2),
+	.reset_gpio = GPIO_BASE + 69,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info as_1140_ti964_sd_2 = {
+	.csi2 = &as_1140_ti964_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			 .type = "ti964",
+			 .addr = TI964_I2C_ADDRESS,
+			 .platform_data = &as_1140_ti964_pdata_2,
+		},
+		.i2c_adapter_id = AS_1140_TI964_I2C_ADAPTER_2,
+	}
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OX03A10
+#define OX03A10_LANES	4
+#define OX03A10_I2C_PHY_ADDR   0x6c
+#define OX03A10A_I2C_ADDRESS   0x30
+#define OX03A10B_I2C_ADDRESS   0x31
+
+#define OX03A10A_SER_ADDRESS   0x58
+#define OX03A10B_SER_ADDRESS   0x59
+
+static struct crlmodule_platform_data ox03a10_pdata = {
+	.lanes = OX03A10_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t[]){ 87750000 },
+	.module_name = "OX03A10",
+	.id_string = "0x58 0x3 0x41",
+	/*
+	 * TI960 has 4 gpio pins, for PWDN, FSIN, and etc.
+	 * it depends connection between serializer and sensor,
+	 * please specify xshutdown, fsin as needed.
+	 */
+	.fsin = 0, /* gpio 0 used for FSIN */
+	.gpio_powerup_seq = {0, 3, -1, -1},
+	.module_flags = CRL_MODULE_FL_INIT_SER | CRL_MODULE_FL_POWERUP,
+};
+#endif
+
+#ifdef CONFIG_INTEL_IPU4_OX03A10_FICOSA
+#define OX03A10_FICOSA_LANES		4
+#define OX03A10_FICOSA_I2C_PHY_ADDR	0x6c
+#define OX03A10_FICOSAA_I2C_ADDRESS	0x30
+#define OX03A10_FICOSAB_I2C_ADDRESS	0x31
+
+#define OX03A10_FICOSAA_SER_ADDRESS	0x58
+#define OX03A10_FICOSAB_SER_ADDRESS	0x59
+
+static struct crlmodule_platform_data ox03a10_ficosa_pdata = {
+	.lanes = OX03A10_FICOSA_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t[]){ 87750000 },
+	.module_name = "OX03A10_FICOSA",
+	.id_string = "0x58 0x3 0x41",
+	.gpio_powerup_seq = {0x2, 0xa, 0xe, -1},
+	.module_flags = CRL_MODULE_FL_INIT_SER | CRL_MODULE_FL_POWERUP,
+};
+#endif
+
+
+#ifdef CONFIG_INTEL_IPU4_OV495
+#define OV495_LANES    4
+#define OV495_I2C_PHY_ADDR   0x48
+#define OV495A_I2C_ADDRESS   0x30
+#define OV495B_I2C_ADDRESS   0x31
+#define OV495C_I2C_ADDRESS   0x32
+#define OV495D_I2C_ADDRESS   0x33
+
+#define OV495A_SER_ADDRESS   0x58
+#define OV495B_SER_ADDRESS   0x59
+#define OV495C_SER_ADDRESS   0x5a
+#define OV495D_SER_ADDRESS   0x5b
+
+static struct crlmodule_platform_data ov495_pdata = {
+	.lanes = OV495_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t[]){ 87750000 },
+	.module_name = "OV495",
+	.id_string = "0x51 0x49 0x56 0x4f",
+	/*
+	 * TI960 has 4 gpio pins, for PWDN, FSIN, and etc.
+	 * it depends connection between serializer and sensor,
+	 * please specify xshutdown, fsin as needed.
+	 */
+	.fsin = 2, /* gpio 2 used for FSIN */
+	.reset = 0, /* gpio 0 used for RESET */
+	.module_flags = CRL_MODULE_FL_RESET,
+};
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+#define TI960_I2C_ADAPTER	2
+#define TI960_I2C_ADAPTER_2	4
+#define TI960_LANES	4
+
+static struct ipu_isys_csi2_config ti960_csi2_cfg = {
+	.nlanes = TI960_LANES,
+	.port = 0,
+};
+
+static struct ipu_isys_csi2_config ti960_csi2_cfg_2 = {
+	.nlanes = TI960_LANES,
+	.port = 4,
+};
+
+static struct ti960_subdev_info ti960_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_OV495
+/*
+ * FIXME: ov495 need to be detected first.
+ * it causes side effect on ov495, that initial sequence
+ * of serializer TI953 for other sensors.
+ */
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495A_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495A_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495B_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495B_SER_ADDRESS,
+		.suffix = 'b',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495C_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 2,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495C_SER_ADDRESS,
+		.suffix = 'c',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495D_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 3,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495D_SER_ADDRESS,
+		.suffix = 'd',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OX03A10
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10A_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10A_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10B_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10B_SER_ADDRESS,
+		.suffix = 'b',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OX03A10_FICOSA
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10_FICOSAA_I2C_ADDRESS,
+			.platform_data = &ox03a10_ficosa_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 0,
+		.phy_i2c_addr = OX03A10_FICOSA_I2C_PHY_ADDR,
+		.ser_alias = OX03A10_FICOSAA_SER_ADDRESS,
+		.suffix = 'a',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10_FICOSAB_I2C_ADDRESS,
+			.platform_data = &ox03a10_ficosa_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+		.rx_port = 1,
+		.phy_i2c_addr = OX03A10_FICOSA_I2C_PHY_ADDR,
+		.ser_alias = OX03A10_FICOSAB_SER_ADDRESS,
+		.suffix = 'b',
+	},
+#endif
+};
+
+static struct ti960_subdev_info ti960_subdevs_2[] = {
+#ifdef CONFIG_INTEL_IPU4_OX03A10
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10A_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10A_SER_ADDRESS,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10B_I2C_ADDRESS,
+			.platform_data = &ox03a10_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OX03A10_I2C_PHY_ADDR,
+		.ser_alias = OX03A10B_SER_ADDRESS,
+		.suffix = 'f',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV495
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495A_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495A_SER_ADDRESS,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495B_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495B_SER_ADDRESS,
+		.suffix = 'f',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495C_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 2,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495C_SER_ADDRESS,
+		.suffix = 'g',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OV495D_I2C_ADDRESS,
+			.platform_data = &ov495_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 3,
+		.phy_i2c_addr = OV495_I2C_PHY_ADDR,
+		.ser_alias = OV495D_SER_ADDRESS,
+		.suffix = 'h',
+	},
+#endif
+#ifdef CONFIG_INTEL_IPU4_OX03A10_FICOSA
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10_FICOSAA_I2C_ADDRESS,
+			.platform_data = &ox03a10_ficosa_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 0,
+		.phy_i2c_addr = OX03A10_FICOSA_I2C_PHY_ADDR,
+		.ser_alias = OX03A10_FICOSAA_SER_ADDRESS,
+		.suffix = 'e',
+	},
+	{
+		.board_info = {
+			.type = CRLMODULE_NAME,
+			.addr = OX03A10_FICOSAB_I2C_ADDRESS,
+			.platform_data = &ox03a10_ficosa_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+		.rx_port = 1,
+		.phy_i2c_addr = OX03A10_FICOSA_I2C_PHY_ADDR,
+		.ser_alias = OX03A10_FICOSAB_SER_ADDRESS,
+		.suffix = 'f',
+	},
+#endif
+};
+
+static struct ti960_pdata ti960_pdata = {
+	.subdev_info = ti960_subdevs,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs),
+	.reset_gpio = GPIO_BASE + 63,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info ti960_sd = {
+	.csi2 = &ti960_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS,
+			 .platform_data = &ti960_pdata,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER,
+	}
+};
+
+static struct ti960_pdata ti960_pdata_2 = {
+	.subdev_info = ti960_subdevs_2,
+	.subdev_num = ARRAY_SIZE(ti960_subdevs_2),
+	.reset_gpio = GPIO_BASE + 66,
+	.suffix = 'b',
+};
+
+static struct ipu_isys_subdev_info ti960_sd_2 = {
+	.csi2 = &ti960_csi2_cfg_2,
+	.i2c = {
+		.board_info = {
+			 .type = "ti960",
+			 .addr = TI960_I2C_ADDRESS,
+			 .platform_data = &ti960_pdata_2,
+		},
+		.i2c_adapter_id = TI960_I2C_ADAPTER_2,
+	}
+};
+#endif
+
+
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286_INTEL)
+#define DS_MAX9286_LANES                4
+#define DS_MAX9286_I2C_ADAPTER          4
+#define DS_MAX9286_I2C_ADDRESS          0x48
+
+// This isn't used unless the MAX9286 is built.
+// This module is built with flags that make this an error.
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+#define AR0231AT_LANES            4
+#define AR0231ATA_I2C_ADDRESS      0x11
+#define AR0231ATB_I2C_ADDRESS      0x12
+#define AR0231ATC_I2C_ADDRESS      0x13
+#define AR0231ATD_I2C_ADDRESS      0x14
+
+static struct crlmodule_platform_data ar0231at_pdata = {
+	.lanes = AR0231AT_LANES,
+	.ext_clk = 27000000,
+	.op_sys_clock = (uint64_t[]){ 87750000 },
+	.module_name = "AR0231AT",
+};
+#endif
+
+static struct ipu_isys_csi2_config max9286_csi2_cfg = {
+	.nlanes = DS_MAX9286_LANES,
+	.port = 4,
+};
+
+static struct max9286_subdev_i2c_info max9286_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATA_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'a',
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATB_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'b',
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATC_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'c',
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATD_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+			.suffix = 'd',
+		},
+#endif
+};
+
+static struct max9286_pdata max9286_pdata = {
+	.subdev_info = max9286_subdevs,
+	.subdev_num = ARRAY_SIZE(max9286_subdevs),
+	.reset_gpio = GPIO_BASE + 63,
+	.suffix = 'a',
+};
+
+static struct ipu_isys_subdev_info max9286_sd = {
+	.csi2 = &max9286_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			.type = "max9286_intel",
+			.addr = DS_MAX9286_I2C_ADDRESS,
+			.platform_data = &max9286_pdata,
+		},
+		.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER,
+	}
+};
+#endif
+
+/*
+ * Map buttress output sensor clocks to sensors -
+ * this should be coming from ACPI
+ */
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT("2-0036", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("2-001a", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-001a", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT("2-0010", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-0010", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT("2-a0e0", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("2-a0e2", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("0-0010", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("2-000e", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-000e", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT("0-0048", NULL, NULL), "OSC_CLK_OUT0" },
+	{ CLKDEV_INIT("4-0048", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+#ifdef CONFIG_INTEL_IPU4_OV2740
+		&ov2740_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX185
+		&imx185_crl_sd,
+		&imx185_b_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_AR023Z
+		&ar023z_crl_sd,
+		&ar023z_b_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX477
+		&imx477_crl_sd_slave_1,
+		&imx477_crl_sd_master,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX274
+		&imx274_crl_sd,
+		&imx274_b_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_IMX290
+		&imx290_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV13860
+		&ov13860_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_OV9281
+		&ov9281_crl_sd,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_BU64295)
+		&bu64295_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_ADV7481
+		&adv7481_crl_sd,
+#endif
+#ifdef CONFIG_INTEL_IPU4_ADV7481_EVAL
+		&adv7481_eval_crl_sd,
+		&adv7481b_eval_crl_sd,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_AGGREGATOR_STUB)
+		&video_aggre_stub_sd,
+		&video_aggre_b_stub_sd,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_TI964)
+		&ti964_sd,
+		&ti964_sd_2,
+		&as_1140_ti964_sd,
+		&as_1140_ti964_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_TI960)
+		&ti960_sd,
+		&ti960_sd_2,
+#endif
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286_INTEL)
+		&max9286_sd,
+#endif
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+static void ipu4_quirk(struct pci_dev *pci_dev)
+{
+	pci_dev->dev.platform_data = &pdata;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU_PCI_ID, ipu4_quirk);
diff --git a/drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c b/drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c
new file mode 100644
index 000000000000..7be6507a33e8
--- /dev/null
+++ b/drivers/media/platform/intel/ipu4p-icl-rvp-pdata.c
@@ -0,0 +1,182 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2018 Intel Corporation
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+
+#include <media/ipu-isys.h>
+#include <media/max9286.h>
+#include "ipu.h"
+#include <media/crlmodule.h>
+
+#define IMX355_LANES		4
+#define IMX355_I2C_ADDRESS	0x1a
+#define IMX319_LANES		4
+#define IMX319_I2C_ADDRESS	0x10
+#define AK7375_I2C_ADDRESS	0xc
+
+static struct ipu_isys_csi2_config imx355_csi2_cfg = {
+	.nlanes = IMX355_LANES,
+	.port = 4, /* WF camera */
+};
+
+static struct ipu_isys_subdev_info imx355_sd = {
+	.csi2 = &imx355_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("imx355", IMX355_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 9,
+	}
+};
+
+/* FIXME: Remove this after hardware transition. */
+static struct ipu_isys_subdev_info imx355_sd2 = {
+	.csi2 = &imx355_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			 I2C_BOARD_INFO("imx355", 0x10),
+		},
+		.i2c_adapter_id = 9,
+	}
+};
+
+static struct ipu_isys_subdev_info ak7375_sd = {
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("ak7375", AK7375_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 9,
+	}
+};
+
+static struct ipu_isys_csi2_config imx319_csi2_cfg = {
+	.nlanes = IMX319_LANES,
+	.port = 0, /* UF camera */
+};
+
+static struct ipu_isys_subdev_info imx319_sd = {
+	.csi2 = &imx319_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			I2C_BOARD_INFO("imx319", IMX319_I2C_ADDRESS),
+		},
+		.i2c_adapter_id = 8,
+	}
+};
+
+
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286)
+#define DS_MAX9286_LANES                4
+#define DS_MAX9286_I2C_ADAPTER_B        3
+#define DS_MAX9286_I2C_ADDRESS          0x48
+
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+#define AR0231AT_LANES            4
+#define AR0231ATA_I2C_ADDRESS      0x11
+#define AR0231ATB_I2C_ADDRESS      0x12
+#define AR0231ATC_I2C_ADDRESS      0x13
+#define AR0231ATD_I2C_ADDRESS      0x14
+
+static struct crlmodule_platform_data ar0231at_pdata = {
+	.lanes = AR0231AT_LANES,
+	.ext_clk = 24000000,
+	.op_sys_clock = (uint64_t[]){ 264000000 },
+	.module_name = "AR0231AT",
+};
+#endif
+
+static struct ipu_isys_csi2_config max9286_b_csi2_cfg = {
+	.nlanes = DS_MAX9286_LANES,
+	.port = 4,
+};
+
+struct max9286_subdev_i2c_info max9286_b_subdevs[] = {
+#ifdef CONFIG_INTEL_IPU4_AR0231AT
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATA_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATB_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATC_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+		{
+			.board_info = {
+				.type = CRLMODULE_NAME,
+				.addr = AR0231ATD_I2C_ADDRESS,
+				.platform_data = &ar0231at_pdata,
+			},
+			.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+		},
+#endif
+};
+
+static struct max9286_pdata max9286_b_pdata = {
+	.subdev_info = max9286_b_subdevs,
+	.subdev_num = ARRAY_SIZE(max9286_b_subdevs),
+	.reset_gpio = 195,
+};
+
+static struct ipu_isys_subdev_info max9286_b_sd = {
+	.csi2 = &max9286_b_csi2_cfg,
+	.i2c = {
+		.board_info = {
+			.type = "max9286",
+			.addr = DS_MAX9286_I2C_ADDRESS,
+			.platform_data = &max9286_b_pdata,
+		},
+		.i2c_adapter_id = DS_MAX9286_I2C_ADAPTER_B,
+	}
+};
+#endif
+
+static struct ipu_isys_clk_mapping clk_mapping[] = {
+	{ CLKDEV_INIT("3-0048", NULL, NULL), "OSC_CLK_OUT1" },
+	{ CLKDEV_INIT(NULL, NULL, NULL), NULL }
+};
+
+static struct ipu_isys_subdev_pdata pdata = {
+	.subdevs = (struct ipu_isys_subdev_info *[]) {
+		&imx355_sd,
+		&imx355_sd2,
+		&imx319_sd,
+		&ak7375_sd,
+#if IS_ENABLED(CONFIG_VIDEO_MAX9286)
+		&max9286_b_sd,
+#endif
+		NULL,
+	},
+	.clk_map = clk_mapping,
+};
+
+static void ipu4p_quirk(struct pci_dev *pci_dev)
+{
+	pr_info("Intel platform data PCI quirk for IPU4P\n");
+	pci_dev->dev.platform_data = &pdata;
+}
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, IPU_PCI_ID, ipu4p_quirk);
+
+MODULE_AUTHOR("Bingbu Cao <bingbu.cao@intel.com>");
+MODULE_AUTHOR("Qiu, Tianshu <tian.shu.qiu@intel.com>");
+MODULE_AUTHOR("Kun Jiang <kun.jiang@intel.com>");
+MODULE_LICENSE("GPL");
-- 
2.34.1

