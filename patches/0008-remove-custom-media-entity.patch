From 6245d6b6b9e0c754ce2cf5f7a8738d7c482c373d Mon Sep 17 00:00:00 2001
From: ruslanbay <67730802+ruslanbay@users.noreply.github.com>
Date: Sun, 23 Nov 2025 12:06:41 +0100
Subject: [PATCH 8/9] IPU4: drop everything that requires intel's own
 /include/media/media-entity.h implementation

---
 drivers/media/i2c/Kconfig                     | 126 ++++-----
 drivers/media/i2c/Makefile                    |  14 +-
 drivers/media/i2c/crlmodule/crlmodule-data.c  |  16 +-
 .../media/pci/intel/ipu-isys-csi2-be-soc.c    |   6 +-
 drivers/media/pci/intel/ipu-isys-csi2.c       |   9 -
 drivers/media/pci/intel/ipu-isys-media.h      |  80 ------
 drivers/media/pci/intel/ipu-isys-subdev.c     |  34 ---
 drivers/media/pci/intel/ipu-isys-subdev.h     |   2 -
 drivers/media/pci/intel/ipu-isys-video.c      |  28 +-
 drivers/media/pci/intel/ipu-isys.c            | 247 ------------------
 drivers/media/platform/intel/Kconfig          |  36 +--
 11 files changed, 102 insertions(+), 496 deletions(-)

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 2ba586897c2d..d5785679b399 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -465,30 +465,30 @@ config VIDEO_VPX3220
 	  To compile this driver as a module, choose M here: the
 	  module will be called vpx3220.
 
-config VIDEO_MAX9286_INTEL
-	tristate "Maxim MAX9286 GMSL deserializer support"
-	depends on I2C && I2C_MUX
-	select V4L2_FWNODE
-	select VIDEO_V4L2_SUBDEV_API
-	select MEDIA_CONTROLLER
-	help
-	  This driver supports the Maxim MAX9286 GMSL deserializer.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called max9286_intel.
-
-config VIDEO_MAX9286
-	tristate "Maxim MAX9286 GMSL deserializer support"
-	depends on I2C && I2C_MUX
-	depends on OF_GPIO
-	select V4L2_FWNODE
-	select VIDEO_V4L2_SUBDEV_API
-	select MEDIA_CONTROLLER
-	help
-	  This driver supports the Maxim MAX9286 GMSL deserializer.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called max9286.
+# config VIDEO_MAX9286_INTEL
+# 	tristate "Maxim MAX9286 GMSL deserializer support"
+# 	depends on I2C && I2C_MUX
+# 	select V4L2_FWNODE
+# 	select VIDEO_V4L2_SUBDEV_API
+# 	select MEDIA_CONTROLLER
+# 	help
+# 	  This driver supports the Maxim MAX9286 GMSL deserializer.
+# 
+# 	  To compile this driver as a module, choose M here: the
+# 	  module will be called max9286_intel.
+
+# config VIDEO_MAX9286
+# 	tristate "Maxim MAX9286 GMSL deserializer support"
+# 	depends on I2C && I2C_MUX
+# 	depends on OF_GPIO
+# 	select V4L2_FWNODE
+# 	select VIDEO_V4L2_SUBDEV_API
+# 	select MEDIA_CONTROLLER
+# 	help
+# 	  This driver supports the Maxim MAX9286 GMSL deserializer.
+# 
+# 	  To compile this driver as a module, choose M here: the
+# 	  module will be called max9286.
 
 comment "Video and audio decoders"
 
@@ -728,12 +728,12 @@ config VIDEO_ST_MIPID02
 	  To compile this driver as a module, choose M here: the
 	  module will be called st-mipid02.
 
-config VIDEO_TI964
-	tristate "TI964 driver support"
-	depends on I2C && VIDEO_V4L2
-    depends on GPIOLIB
-	help
-	    This is a driver for TI964 camera.
+# config VIDEO_TI964
+# 	tristate "TI964 driver support"
+# 	depends on I2C && VIDEO_V4L2
+#     depends on GPIOLIB
+# 	help
+# 	    This is a driver for TI964 camera.
 
 endmenu
 
@@ -1321,33 +1321,33 @@ source "drivers/media/i2c/m5mols/Kconfig"
 config VIDEO_MAX9271_LIB
 	tristate
 
-config VIDEO_RDACM20
-	tristate "IMI RDACM20 camera support"
-	depends on I2C
-	select V4L2_FWNODE
-	select VIDEO_V4L2_SUBDEV_API
-	select MEDIA_CONTROLLER
-	select VIDEO_MAX9271_LIB
-	help
-	  This driver supports the IMI RDACM20 GMSL camera, used in
-	  ADAS systems.
-
-	  This camera should be used in conjunction with a GMSL
-	  deserialiser such as the MAX9286.
-
-config VIDEO_RDACM21
-	tristate "IMI RDACM21 camera support"
-	depends on I2C
-	select V4L2_FWNODE
-	select VIDEO_V4L2_SUBDEV_API
-	select MEDIA_CONTROLLER
-	select VIDEO_MAX9271_LIB
-	help
-	  This driver supports the IMI RDACM21 GMSL camera, used in
-	  ADAS systems.
-
-	  This camera should be used in conjunction with a GMSL
-	  deserialiser such as the MAX9286.
+# config VIDEO_RDACM20
+# 	tristate "IMI RDACM20 camera support"
+# 	depends on I2C
+# 	select V4L2_FWNODE
+# 	select VIDEO_V4L2_SUBDEV_API
+# 	select MEDIA_CONTROLLER
+# 	select VIDEO_MAX9271_LIB
+# 	help
+# 	  This driver supports the IMI RDACM20 GMSL camera, used in
+# 	  ADAS systems.
+# 
+# 	  This camera should be used in conjunction with a GMSL
+# 	  deserialiser such as the MAX9286.
+
+# config VIDEO_RDACM21
+# 	tristate "IMI RDACM21 camera support"
+# 	depends on I2C
+# 	select V4L2_FWNODE
+# 	select VIDEO_V4L2_SUBDEV_API
+# 	select MEDIA_CONTROLLER
+# 	select VIDEO_MAX9271_LIB
+# 	help
+# 	  This driver supports the IMI RDACM21 GMSL camera, used in
+# 	  ADAS systems.
+# 
+# 	  This camera should be used in conjunction with a GMSL
+# 	  deserialiser such as the MAX9286.
 
 config VIDEO_RJ54N1
 	tristate "Sharp RJ54N1CB0C sensor support"
@@ -1411,12 +1411,12 @@ config VIDEO_S5C73M3
 	  This is a V4L2 sensor driver for Samsung S5C73M3
 	  8 Mpixel camera.
 
-config VIDEO_TI960
-	tristate "TI960 driver support"
-	depends on I2C && MEDIA_CONTROLLER && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
-    depends on GPIOLIB
-	help
-	  This is a driver for TI960 Deserializer.
+# config VIDEO_TI960
+# 	tristate "TI960 driver support"
+# 	depends on I2C && MEDIA_CONTROLLER && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+#     depends on GPIOLIB
+# 	help
+# 	  This is a driver for TI960 Deserializer.
 
 endmenu
 
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index a0d1e0a95aba..acbe39651558 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -129,15 +129,15 @@ obj-$(CONFIG_VIDEO_IMX334)	+= imx334.o
 obj-$(CONFIG_VIDEO_IMX335)	+= imx335.o
 obj-$(CONFIG_VIDEO_IMX355)	+= imx355.o
 obj-$(CONFIG_VIDEO_IMX412)	+= imx412.o
-obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
+# obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
 obj-$(CONFIG_VIDEO_MAX9271_LIB)	+= max9271.o
-obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20.o
-obj-$(CONFIG_VIDEO_RDACM21)	+= rdacm21.o
+# obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20.o
+# obj-$(CONFIG_VIDEO_RDACM21)	+= rdacm21.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
 obj-$(CONFIG_SDR_MAX2175) += max2175.o
 
 obj-$(CONFIG_VIDEO_CRLMODULE) += crlmodule/
-obj-$(CONFIG_VIDEO_TI964) += ti964.o
-obj-$(CONFIG_VIDEO_MAX9286_INTEL) += max9286_intel.o
-ti960-objs := ti953-ser.o ti960-des.o
-obj-$(CONFIG_VIDEO_TI960) += ti960.o
+# obj-$(CONFIG_VIDEO_TI964) += ti964.o
+# obj-$(CONFIG_VIDEO_MAX9286_INTEL) += max9286_intel.o
+# ti960-objs := ti953-ser.o ti960-des.o
+# obj-$(CONFIG_VIDEO_TI960) += ti960.o
diff --git a/drivers/media/i2c/crlmodule/crlmodule-data.c b/drivers/media/i2c/crlmodule/crlmodule-data.c
index 517774cd9dbb..43e485ac5df0 100644
--- a/drivers/media/i2c/crlmodule/crlmodule-data.c
+++ b/drivers/media/i2c/crlmodule/crlmodule-data.c
@@ -17,9 +17,9 @@
 #include "crl_adv7481_hdmi_configuration.h"
 #include "crl_adv7481_eval_configuration.h"
 #include "crl_imx185_configuration.h"
-#include "crl_ov10635_configuration.h"
+// #include "crl_ov10635_configuration.h"
 #include "crl_ar0231at_configuration.h"
-#include "crl_ov10640_configuration.h"
+// #include "crl_ov10640_configuration.h"
 #include "crl_imx477_master_configuration.h"
 #include "crl_imx477_slave_configuration.h"
 #include "crl_imx274_configuration.h"
@@ -29,12 +29,12 @@
 #include "crl_pixter_stub_configuration.h"
 #include "crl_ov2740_configuration.h"
 #include "crl_ov9281_configuration.h"
-#include "crl_magna_configuration.h"
+// #include "crl_magna_configuration.h"
 #include "crl_ar023z_configuration.h"
 #include "crl_ov2775_configuration.h"
 #include "crl_ox03a10_configuration.h"
 #include "crl_ox03a10_ficosa_configuration.h"
-#include "crl_ov495_configuration.h"
+// #include "crl_ov495_configuration.h"
 
 static const struct crlmodule_sensors supported_sensors[] = {
 	{ "i2c-SONY214A:00", "imx214", &imx214_crl_configuration },
@@ -56,9 +56,9 @@ static const struct crlmodule_sensors supported_sensors[] = {
 	{ "ADV7481_EVAL", "adv7481_eval", &adv7481_eval_crl_configuration },
 	{ "ADV7481B_EVAL", "adv7481b_eval", &adv7481b_eval_crl_configuration },
 	{ "SONY318A", "imx318", &imx318_crl_configuration },
-	{ "OV10635", "ov10635", &ov10635_crl_configuration },
+	// { "OV10635", "ov10635", &ov10635_crl_configuration },
 	{ "AR0231AT", "ar0231at", &ar0231at_crl_configuration },
-	{ "OV10640", "ov10640", &ov10640_crl_configuration },
+	// { "OV10640", "ov10640", &ov10640_crl_configuration },
 	{ "IMX274", "imx274", &imx274_crl_configuration },
 	{ "OV5670", "ov5670", &ov5670_crl_configuration },
 	{ "OV5693", "ov5693", &ov5693_crl_configuration },
@@ -72,13 +72,13 @@ static const struct crlmodule_sensors supported_sensors[] = {
 	{ "PIXTER_STUB_G", "pixter_stub_g", &pixter_stub_g_crl_configuration},
 	{ "PIXTER_STUB_H", "pixter_stub_h", &pixter_stub_h_crl_configuration},
 	{ "INT3474", "ov2740", &ov2740_crl_configuration },
-	{ "MAGNA", "magna", &magna_crl_configuration },
+	// { "MAGNA", "magna", &magna_crl_configuration },
 	{ "AR023Z", "ar023z", &ar023z_crl_configuration },
 	{ "OV2775", "ov2775", &ov2775_crl_configuration },
 	{ "OX03A10", "ox03a10", &ox03a10_crl_configuration },
 	{ "OX03A10_FICOSA", "ox03a10_ficosa",
 	 &ox03a10_ficosa_crl_configuration },
-	{ "OV495", "ov495", &ov495_crl_configuration},
+	// { "OV495", "ov495", &ov495_crl_configuration},
 };
 
 /*
diff --git a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
index 9253f9f1e505..336ed0c78fcd 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2-be-soc.c
@@ -148,7 +148,6 @@ static struct v4l2_subdev_ops csi2_be_soc_sd_ops = {
 
 static struct media_entity_operations csi2_be_soc_entity_ops = {
 	.link_validate = v4l2_subdev_link_validate,
-	.has_route = ipu_isys_subdev_has_route,
 };
 
 static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
@@ -186,10 +185,7 @@ static void csi2_be_soc_set_ffmt(struct v4l2_subdev *sd,
 		struct ipu_isys_subdev *asd = to_ipu_isys_subdev(sd);
 		unsigned int sink_pad = 0;
 		int i;
-
-		for (i = 0; i < asd->nsinks; i++)
-			if (media_entity_has_route(&sd->entity, fmt->pad, i))
-				break;
+		
 		if (i != asd->nsinks)
 			sink_pad = i;
 		sink_ffmt = __ipu_isys_get_ffmt(sd, cfg, sink_pad,
diff --git a/drivers/media/pci/intel/ipu-isys-csi2.c b/drivers/media/pci/intel/ipu-isys-csi2.c
index 719955bbf540..009ac9dced4c 100644
--- a/drivers/media/pci/intel/ipu-isys-csi2.c
+++ b/drivers/media/pci/intel/ipu-isys-csi2.c
@@ -438,14 +438,6 @@ static int csi2_link_validate(struct media_link *link)
 	return 0;
 }
 
-static bool csi2_has_route(struct media_entity *entity, unsigned int pad0,
-			   unsigned int pad1, int *stream)
-{
-	if (pad0 == CSI2_PAD_META || pad1 == CSI2_PAD_META)
-		return true;
-	return ipu_isys_subdev_has_route(entity, pad0, pad1, stream);
-}
-
 static const struct v4l2_subdev_video_ops csi2_sd_video_ops = {
 	.s_stream = set_stream,
 };
@@ -527,7 +519,6 @@ static struct v4l2_subdev_ops csi2_sd_ops = {
 
 static struct media_entity_operations csi2_entity_ops = {
 	.link_validate = csi2_link_validate,
-	.has_route = csi2_has_route,
 };
 
 static void csi2_set_ffmt(struct v4l2_subdev *sd,
diff --git a/drivers/media/pci/intel/ipu-isys-media.h b/drivers/media/pci/intel/ipu-isys-media.h
index c3dd8d03c3e9..ccda9b6fef9a 100644
--- a/drivers/media/pci/intel/ipu-isys-media.h
+++ b/drivers/media/pci/intel/ipu-isys-media.h
@@ -7,86 +7,6 @@
 #include <linux/slab.h>
 #include <media/media-entity.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)
-#define is_media_entity_v4l2_subdev(e) \
-	(media_entity_type(e) == MEDIA_ENT_T_V4L2_SUBDEV)
-#define is_media_entity_v4l2_io(e) \
-	(media_entity_type(e) == MEDIA_ENT_T_DEVNODE)
-#define media_create_pad_link(a, b, c, d, e)	\
-	media_entity_create_link(a, b, c, d, e)
-#define media_entity_pads_init(a, b, c)	\
-	media_entity_init(a, b, c, 0)
-#define media_entity_id(ent) ((ent)->id)
-#define media_entity_graph_walk_init(a, b) 0
-#define media_entity_graph_walk_cleanup(a) do { } while (0)
-
-#define IPU_COMPAT_MAX_ENTITIES MEDIA_ENTITY_ENUM_MAX_ID
-
-struct media_entity_enum {
-	unsigned long *bmap;
-	int idx_max;
-};
-
-static inline int media_entity_enum_init(struct media_entity_enum *ent_enum,
-			   struct media_device *mdev)
-{
-	int idx_max = IPU_COMPAT_MAX_ENTITIES;
-
-	ent_enum->bmap = kcalloc(DIV_ROUND_UP(idx_max, BITS_PER_LONG),
-				 sizeof(long), GFP_KERNEL);
-	if (!ent_enum->bmap)
-		return -ENOMEM;
-
-	bitmap_zero(ent_enum->bmap, idx_max);
-
-	ent_enum->idx_max = idx_max;
-	return 0;
-}
-
-static inline void media_entity_enum_cleanup(struct media_entity_enum *ent_enum)
-{
-	kfree(ent_enum->bmap);
-}
-
-static inline void media_entity_enum_set(struct media_entity_enum *ent_enum,
-					 struct media_entity *entity)
-{
-	if (media_entity_id(entity) >= ent_enum->idx_max) {
-		WARN_ON(1);
-		return;
-	}
-	__set_bit(media_entity_id(entity), ent_enum->bmap);
-}
-
-static inline void media_entity_enum_zero(struct media_entity_enum *ent_enum)
-{
-	bitmap_zero(ent_enum->bmap, ent_enum->idx_max);
-}
-
-static inline bool media_entity_enum_test(struct media_entity_enum *ent_enum,
-					  struct media_entity *entity)
-{
-	if (media_entity_id(entity) >= ent_enum->idx_max) {
-		WARN_ON(1);
-		return false;
-	}
-
-	return test_bit(media_entity_id(entity), ent_enum->bmap);
-}
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-#define media_pipeline_start(e, p) media_entity_pipeline_start(e, p)
-
-#define media_pipeline_stop(e) media_entity_pipeline_stop(e)
-
-#define media_graph_walk_init(g, d) media_entity_graph_walk_init(g, d)
-
-#define media_graph_walk_start(g, p) media_entity_graph_walk_start(g, p)
-
-#define media_graph_walk_next(g) media_entity_graph_walk_next(g)
-
-#define media_graph_walk_cleanup(g) media_entity_graph_walk_cleanup(g)
-#endif
-
 struct __packed media_request_cmd {
 	__u32 cmd;
 	__u32 request;
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.c b/drivers/media/pci/intel/ipu-isys-subdev.c
index ad4fc8707823..cad8623dec10 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.c
+++ b/drivers/media/pci/intel/ipu-isys-subdev.c
@@ -320,9 +320,6 @@ int ipu_isys_subdev_fmt_propagate(struct v4l2_subdev *sd,
 				goto out_subdev_fmt_propagate;
 			/* n:n case: propagate according to route info */
 		} else if (asd->nsinks == asd->nsources && asd->nsources > 1) {
-			for (i = asd->nsinks; i < sd->entity.num_pads; i++)
-				if (media_entity_has_route(&sd->entity, pad, i))
-					break;
 
 			if (i != sd->entity.num_pads) {
 				compose[i]->left = 0;
@@ -545,37 +542,6 @@ int ipu_isys_subdev_get_frame_desc(struct v4l2_subdev *sd,
 	return rval;
 }
 
-bool ipu_isys_subdev_has_route(struct media_entity *entity,
-			       unsigned int pad0, unsigned int pad1, int *stream)
-{
-	struct ipu_isys_subdev *asd;
-	int i;
-
-	if (!entity) {
-		WARN_ON(1);
-		return false;
-	}
-	asd = to_ipu_isys_subdev(media_entity_to_v4l2_subdev(entity));
-
-	/* Two sinks are never connected together. */
-	if (pad0 < asd->nsinks && pad1 < asd->nsinks)
-		return false;
-
-	for (i = 0; i < asd->nstreams; i++) {
-		if ((asd->route[i].flags & V4L2_SUBDEV_ROUTE_FL_ACTIVE) &&
-		    ((asd->route[i].sink == pad0 &&
-		      asd->route[i].source == pad1) ||
-		     (asd->route[i].sink == pad1 &&
-			  asd->route[i].source == pad0))) {
-			if (stream)
-				*stream = i;
-			return true;
-		}
-	}
-
-	return false;
-}
-
 int ipu_isys_subdev_set_routing(struct v4l2_subdev *sd,
 				struct v4l2_subdev_routing *route)
 {
diff --git a/drivers/media/pci/intel/ipu-isys-subdev.h b/drivers/media/pci/intel/ipu-isys-subdev.h
index b47c85d3ac03..51c05504708b 100644
--- a/drivers/media/pci/intel/ipu-isys-subdev.h
+++ b/drivers/media/pci/intel/ipu-isys-subdev.h
@@ -222,6 +222,4 @@ int ipu_isys_subdev_set_routing(struct v4l2_subdev *sd,
 				struct v4l2_subdev_routing *route);
 int ipu_isys_subdev_get_routing(struct v4l2_subdev *sd,
 				struct v4l2_subdev_routing *route);
-bool ipu_isys_subdev_has_route(struct media_entity *entity,
-			       unsigned int pad0, unsigned int pad1, int *stream);
 #endif /* IPU_ISYS_SUBDEV_H */
diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index cfd80d24e2ab..9bb388c2cd0a 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -1515,7 +1515,7 @@ int ipu_isys_video_prepare_streaming(struct ipu_isys_video *av,
 
 	/* Gather all entities in the graph. */
 	mutex_lock(&mdev->graph_mutex);
-	media_graph_walk_start(&graph, &av->vdev.entity.pads[0]);
+	media_graph_walk_start(&graph, &av->vdev.entity);
 	while ((entity = media_graph_walk_next(&graph)))
 		media_entity_enum_set(&ip->entity_enum, entity);
 
@@ -1632,18 +1632,9 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 
 	mutex_lock(&mdev->graph_mutex);
 
-	media_graph_walk_start(&
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-				      ip->
-#endif
-				      graph,
-				      &av->vdev.entity.pads[0]);
+	media_graph_walk_start(&ip->graph, &av->vdev.entity);
 
-	while ((entity = media_graph_walk_next(&
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-						      ip->
-#endif
-						      graph))) {
+	while ((entity = media_graph_walk_next(&ip->graph))) {
 		sd = media_entity_to_v4l2_subdev(entity);
 
 		dev_dbg(dev, "set stream: entity %s\n", entity->name);
@@ -1716,18 +1707,9 @@ int ipu_isys_video_set_streaming(struct ipu_isys_video *av,
 out_media_entity_stop_streaming:
 	mutex_lock(&mdev->graph_mutex);
 
-	media_graph_walk_start(&
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-				      ip->
-#endif
-				      graph,
-				      &av->vdev.entity.pads[0]);
+	media_graph_walk_start(&ip->graph, &av->vdev.entity);
 
-	while (state && (entity2 = media_graph_walk_next(&
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-								ip->
-#endif
-								graph)) &&
+	while (state && (entity2 = media_graph_walk_next(&ip->graph)) &&
 	       entity2 != entity) {
 		sd = media_entity_to_v4l2_subdev(entity2);
 
diff --git a/drivers/media/pci/intel/ipu-isys.c b/drivers/media/pci/intel/ipu-isys.c
index c131657a8961..8603cce0c3a4 100644
--- a/drivers/media/pci/intel/ipu-isys.c
+++ b/drivers/media/pci/intel/ipu-isys.c
@@ -43,253 +43,6 @@ static bool csi2_port_optimized = true;
 module_param(csi2_port_optimized, bool, 0660);
 MODULE_PARM_DESC(csi2_port_optimized, "IPU CSI2 port optimization");
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
-/*
- * BEGIN adapted code from drivers/media/platform/omap3isp/isp.c.
- * FIXME: This (in terms of functionality if not code) should be most
- * likely generalised in the framework, and use made optional for
- * drivers.
- */
-/*
- * ipu_pipeline_pm_use_count - Count the number of users of a pipeline
- * @entity: The entity
- *
- * Return the total number of users of all video device nodes in the pipeline.
- */
-static int ipu_pipeline_pm_use_count(struct media_pad *pad)
-{
-	struct media_entity_graph graph;
-	struct media_entity *entity = pad->entity;
-	int use = 0;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	media_graph_walk_init(&graph, entity->graph_obj.mdev);
-#endif
-	media_graph_walk_start(&graph, pad);
-
-	while ((entity = media_graph_walk_next(&graph))) {
-		if (is_media_entity_v4l2_io(entity))
-			use += entity->use_count;
-	}
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	media_graph_walk_cleanup(&graph);
-#endif
-	return use;
-}
-
-/*
- * ipu_pipeline_pm_power_one - Apply power change to an entity
- * @entity: The entity
- * @change: Use count change
- *
- * Change the entity use count by @change. If the entity is a subdev update its
- * power state by calling the core::s_power operation when the use count goes
- * from 0 to != 0 or from != 0 to 0.
- *
- * Return 0 on success or a negative error code on failure.
- */
-static int ipu_pipeline_pm_power_one(struct media_entity *entity, int change)
-{
-	struct v4l2_subdev *subdev;
-	int ret;
-
-	subdev = is_media_entity_v4l2_subdev(entity)
-	    ? media_entity_to_v4l2_subdev(entity) : NULL;
-
-	if (entity->use_count == 0 && change > 0 && subdev) {
-		ret = v4l2_subdev_call(subdev, core, s_power, 1);
-		if (ret < 0 && ret != -ENOIOCTLCMD)
-			return ret;
-	}
-
-	entity->use_count += change;
-	WARN_ON(entity->use_count < 0);
-
-	if (entity->use_count == 0 && change < 0 && subdev)
-		v4l2_subdev_call(subdev, core, s_power, 0);
-
-	return 0;
-}
-
-/*
- * ipu_get_linked_pad - Find internally connected pad for a given pad
- * @entity: The entity
- * @pad: Initial pad
- *
- * Return index of the linked pad.
- */
-static int ipu_get_linked_pad(struct media_entity *entity,
-			      struct media_pad *pad)
-{
-	int i;
-
-	for (i = 0; i < entity->num_pads; i++) {
-		struct media_pad *opposite_pad = &entity->pads[i];
-
-		if (opposite_pad == pad)
-			continue;
-
-		if (media_entity_has_route(entity, pad->index,
-					   opposite_pad->index))
-			return opposite_pad->index;
-	}
-
-	return 0;
-}
-
-/*
- * ipu_pipeline_pm_power - Apply power change to all entities
- * in a pipeline
- * @entity: The entity
- * @change: Use count change
- * @from_pad: Starting pad
- *
- * Walk the pipeline to update the use count and the power state of
- * all non-node
- * entities.
- *
- * Return 0 on success or a negative error code on failure.
- */
-static int ipu_pipeline_pm_power(struct media_entity *entity,
-				 int change, int from_pad)
-{
-	struct media_entity_graph graph;
-	struct media_entity *first = entity;
-	int ret = 0;
-
-	if (!change)
-		return 0;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	media_graph_walk_init(&graph, entity->graph_obj.mdev);
-#endif
-	media_graph_walk_start(&graph, &entity->pads[from_pad]);
-
-	while (!ret && (entity = media_graph_walk_next(&graph)))
-		if (!is_media_entity_v4l2_io(entity))
-			ret = ipu_pipeline_pm_power_one(entity, change);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	media_graph_walk_cleanup(&graph);
-#endif
-	if (!ret)
-		return 0;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	media_graph_walk_init(&graph, entity->graph_obj.mdev);
-#endif
-	media_graph_walk_start(&graph, &first->pads[from_pad]);
-
-	while ((first = media_graph_walk_next(&graph)) &&
-	       first != entity)
-		if (!is_media_entity_v4l2_io(first))
-			ipu_pipeline_pm_power_one(first, -change);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	media_graph_walk_cleanup(&graph);
-#endif
-	return ret;
-}
-
-/*
- * ipu_pipeline_pm_use - Update the use count of an entity
- * @entity: The entity
- * @use: Use (1) or stop using (0) the entity
- *
- * Update the use count of all entities in the pipeline and power entities
- * on or off accordingly.
- *
- * Return 0 on success or a negative error code on failure. Powering entities
- * off is assumed to never fail. No failure can occur when the use parameter is
- * set to 0.
- */
-int ipu_pipeline_pm_use(struct media_entity *entity, int use)
-{
-	int change = use ? 1 : -1;
-	int ret;
-
-	mutex_lock(&entity->
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)
-		   parent
-#else
-		   graph_obj.mdev
-#endif
-		   ->graph_mutex);
-
-	/* Apply use count to node. */
-	entity->use_count += change;
-	WARN_ON(entity->use_count < 0);
-
-	/* Apply power change to connected non-nodes. */
-	ret = ipu_pipeline_pm_power(entity, change, 0);
-	if (ret < 0)
-		entity->use_count -= change;
-
-	mutex_unlock(&entity->
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)
-		     parent
-#else
-		     graph_obj.mdev
-#endif
-		     ->graph_mutex);
-
-	return ret;
-}
-
-/*
- * ipu_pipeline_link_notify - Link management notification callback
- * @link: The link
- * @flags: New link flags that will be applied
- * @notification: The link's state change notification type
- * (MEDIA_DEV_NOTIFY_*)
- *
- * React to link management on powered pipelines by updating the use count of
- * all entities in the source and sink sides of the link. Entities are powered
- * on or off accordingly.
- *
- * Return 0 on success or a negative error code on failure. Powering entities
- * off is assumed to never fail. This function will not fail for disconnection
- * events.
- */
-static int ipu_pipeline_link_notify(struct media_link *link, u32 flags,
-				    unsigned int notification)
-{
-	struct media_entity *source = link->source->entity;
-	struct media_entity *sink = link->sink->entity;
-	int source_use = ipu_pipeline_pm_use_count(link->source);
-	int sink_use = ipu_pipeline_pm_use_count(link->sink);
-	int ret;
-
-	if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&
-	    !(flags & MEDIA_LNK_FL_ENABLED)) {
-		/* Powering off entities is assumed to never fail. */
-		ipu_pipeline_pm_power(source, -sink_use, 0);
-		ipu_pipeline_pm_power(sink, -source_use, 0);
-		return 0;
-	}
-
-	if (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&
-	    (flags & MEDIA_LNK_FL_ENABLED)) {
-		int from_pad = ipu_get_linked_pad(source, link->source);
-
-		ret = ipu_pipeline_pm_power(source, sink_use, from_pad);
-		if (ret < 0)
-			return ret;
-
-		ret = ipu_pipeline_pm_power(sink, source_use, 0);
-		if (ret < 0)
-			ipu_pipeline_pm_power(source, -sink_use, 0);
-
-		return ret;
-	}
-
-	return 0;
-}
-
-/* END adapted code from drivers/media/platform/omap3isp/isp.c */
-#endif /* < v4.6 */
-
 struct isys_i2c_test {
 	u8 bus_nr;
 	u16 addr;
diff --git a/drivers/media/platform/intel/Kconfig b/drivers/media/platform/intel/Kconfig
index ac85770eca86..796abcb5731e 100644
--- a/drivers/media/platform/intel/Kconfig
+++ b/drivers/media/platform/intel/Kconfig
@@ -45,21 +45,21 @@ config INTEL_IPU4_OV9281
 	help
 		Omnivision 1MP camera sensor
 
-config INTEL_IPU4_OV10635
-	bool "Compile platform data for OV10635"
-	help
-		Omnivision 1MP camera sensor
+# config INTEL_IPU4_OV10635
+# 	bool "Compile platform data for OV10635"
+# 	help
+# 		Omnivision 1MP camera sensor
 
 config INTEL_IPU4_AR0231AT
         bool "Compile platform data for AR0231AT"
         help
 	        AR0231 camera sensor for MAXIM 9286
 
-config INTEL_IPU4_MAGNA
-	bool "Compile platform data for MAGNA"
-        depends on INTEL_IPU4_BXT_P_PDATA
-	help
-		MAGNA Camera Sensor
+# config INTEL_IPU4_MAGNA
+# 	bool "Compile platform data for MAGNA"
+#         depends on INTEL_IPU4_BXT_P_PDATA
+# 	help
+# 		MAGNA Camera Sensor
 
 config INTEL_IPU4_IMX274
 	bool "Compile platform data for IMX274 camera sensor"
@@ -67,10 +67,10 @@ config INTEL_IPU4_IMX274
 	help
 		Sony 14MP camera sensor is enabled for HDR function.
 
-config INTEL_IPU4_OV10640
-	bool "Compile platform data for OV10640"
-	help
-		  Omnivision 1.4MP camera sensor
+# config INTEL_IPU4_OV10640
+# 	bool "Compile platform data for OV10640"
+# 	help
+# 		  Omnivision 1.4MP camera sensor
 
 config INTEL_IPU4_ADV7481
 	bool "Compile platform data for ADV7481"
@@ -100,11 +100,11 @@ config INTEL_IPU4_OX03A10_FICOSA
 	help
 		"ox03a10 ficosa camera sensor"
 
-config INTEL_IPU4_OV495
-	bool "Compile platorm data for OV495"
-	depends on INTEL_IPU4_BXT_P_PDATA
-	help
-		"ov495 camera sensor"
+# config INTEL_IPU4_OV495
+# 	bool "Compile platorm data for OV495"
+# 	depends on INTEL_IPU4_BXT_P_PDATA
+# 	help
+# 		"ov495 camera sensor"
 
 config INTEL_IPU4_ADV7481_I2C_ID
         int "I2C bus ID for ADV7481"
-- 
2.34.1

