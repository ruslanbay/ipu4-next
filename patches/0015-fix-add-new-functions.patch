From c73aa051412b2733479109f136d273078db2792e Mon Sep 17 00:00:00 2001
From: ruslanbay <67730802+ruslanbay@users.noreply.github.com>
Date: Fri, 28 Nov 2025 18:57:03 +0100
Subject: [PATCH 15/16] fix: add new functions

https://github.com/intel/linux-intel-lts/blob/lts-v6.1.120-linux-241226T022850Z/drivers/media/pci/intel/ipu-isys-video.h
---
 drivers/media/pci/intel/ipu-isys-video.c      | 136 ++++++++++++++++++
 drivers/media/pci/intel/ipu-isys-video.h      |  25 ++++
 .../media/pci/intel/ipu4/ipu-platform-isys.h  |   2 +
 include/uapi/linux/ipu-isys.h                 |   3 +
 4 files changed, 166 insertions(+)

diff --git a/drivers/media/pci/intel/ipu-isys-video.c b/drivers/media/pci/intel/ipu-isys-video.c
index 4861279b3..0928ba92a 100644
--- a/drivers/media/pci/intel/ipu-isys-video.c
+++ b/drivers/media/pci/intel/ipu-isys-video.c
@@ -907,6 +907,142 @@ static void csi_short_packet_prepare_firmware_stream_cfg(
 #endif
 }
 
+#define MEDIA_ENTITY_MAX_PADS		512
+
+static bool is_support_vc(struct media_pad *source_pad,
+			  struct ipu_isys_pipeline *ip)
+{
+	struct media_pad *remote_pad = source_pad;
+	struct media_pad *extern_pad = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct v4l2_query_ext_ctrl qm_ctrl = {
+		.id = V4L2_CID_IPU_QUERY_SUB_STREAM, };
+	int i;
+
+	while ((remote_pad =
+		media_pad_remote_pad_first(&remote_pad->entity->pads[0])
+		)) {
+		/* Non-subdev nodes can be safely ignored here. */
+		if (!is_media_entity_v4l2_subdev(remote_pad->entity))
+			continue;
+
+		/* Don't start truly external devices quite yet. */
+		if (strncmp(remote_pad->entity->name,
+		    IPU_ISYS_CSI2_ENTITY_PREFIX,
+		    strlen(IPU_ISYS_CSI2_ENTITY_PREFIX)) != 0)
+			continue;
+
+		dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+			"It finds CSI2 %s\n", remote_pad->entity->name);
+		extern_pad =
+			media_pad_remote_pad_first(&remote_pad->entity->pads[0]);
+		if (!extern_pad) {
+			dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+				"extern_pad is null\n");
+			return false;
+		}
+		sd = media_entity_to_v4l2_subdev(extern_pad->entity);
+		break;
+	}
+
+	if (!sd) {
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"It doesn't find extern entity\n");
+		return false;
+	}
+
+	if (v4l2_query_ext_ctrl(sd->ctrl_handler, &qm_ctrl)) {
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"%s, No vc\n", __func__);
+		for (i = 0; i < CSI2_BE_SOC_SOURCE_PADS_NUM; i++)
+			ip->asv[i].vc = 0;
+
+		return false;
+	}
+
+	return true;
+}
+
+static int ipu_isys_query_sensor_info(struct media_pad *source_pad,
+				      struct ipu_isys_pipeline *ip)
+{
+	int i;
+	int ret = -ENOLINK;
+	bool flag = false;
+	unsigned int pad_id = source_pad->index;
+	struct media_pad *remote_pad = source_pad;
+	struct media_pad *extern_pad = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct v4l2_querymenu qm = {.id = V4L2_CID_IPU_QUERY_SUB_STREAM, };
+
+	while ((remote_pad =
+		media_pad_remote_pad_first(&remote_pad->entity->pads[0])
+		)) {
+		/* Non-subdev nodes can be safely ignored here. */
+		if (!is_media_entity_v4l2_subdev(remote_pad->entity))
+			continue;
+
+		/* Don't start truly external devices quite yet. */
+		if (strncmp(remote_pad->entity->name,
+		    IPU_ISYS_CSI2_ENTITY_PREFIX,
+		    strlen(IPU_ISYS_CSI2_ENTITY_PREFIX)) != 0)
+			continue;
+
+		dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+			"It finds CSI2 %s\n", remote_pad->entity->name);
+		extern_pad =
+			media_pad_remote_pad_first(&remote_pad->entity->pads[0]);
+		if (!extern_pad) {
+			dev_dbg(remote_pad->entity->graph_obj.mdev->dev,
+				"extern_pad is null\n");
+			return -ENOLINK;
+		}
+		sd = media_entity_to_v4l2_subdev(extern_pad->entity);
+		break;
+	}
+
+	if (!sd) {
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"It doesn't find extern entity\n");
+		return -ENOLINK;
+	}
+
+	/* Get the sub stream info and set the current pipe's vc id */
+	for (i = 0; i < CSI2_BE_SOC_SOURCE_PADS_NUM; i++) {
+		/*
+		 * index is sub stream id. sub stream id is
+		 * equalto BE SOC source pad id - sink pad count
+		 */
+		qm.index = i;
+		ret = v4l2_querymenu(sd->ctrl_handler, &qm);
+		if (ret)
+			continue;
+
+		/* get sub stream info by sub stream id */
+		ip->asv[qm.index].substream = qm.index;
+		ip->asv[qm.index].code = SUB_STREAM_CODE(qm.value);
+		ip->asv[qm.index].height = SUB_STREAM_H(qm.value);
+		ip->asv[qm.index].width = SUB_STREAM_W(qm.value);
+		ip->asv[qm.index].dt = SUB_STREAM_DT(qm.value);
+		ip->asv[qm.index].vc = SUB_STREAM_VC_ID(qm.value);
+		if (ip->asv[qm.index].substream ==
+			(pad_id - NR_OF_CSI2_BE_SOC_SINK_PADS)) {
+			ip->vc = ip->asv[qm.index].vc;
+			flag = true;
+			pr_info("The current entity vc:id:%d\n", ip->vc);
+		}
+		dev_dbg(source_pad->entity->graph_obj.mdev->dev,
+			"dentity vc:%d, dt:%x, substream:%d\n",
+			ip->vc, ip->asv[qm.index].dt,
+			ip->asv[qm.index].substream);
+	}
+
+	if (flag)
+		return 0;
+
+	return ret;
+}
+
 void ipu_isys_prepare_firmware_stream_cfg_default(
 			struct ipu_isys_video *av,
 			struct ipu_fw_isys_stream_cfg_data_abi *cfg)
diff --git a/drivers/media/pci/intel/ipu-isys-video.h b/drivers/media/pci/intel/ipu-isys-video.h
index 8eb8f614a..9d7cb2bbb 100644
--- a/drivers/media/pci/intel/ipu-isys-video.h
+++ b/drivers/media/pci/intel/ipu-isys-video.h
@@ -16,6 +16,8 @@
 #define IPU_ISYS_OUTPUT_PINS 11
 #define IPU_NUM_CAPTURE_DONE 2
 #define IPU_ISYS_MAX_PARALLEL_SOF 2
+#define NR_OF_CSI2_BE_SOC_STREAMS	8
+#define CSI2_BE_SOC_SOURCE_PADS_NUM NR_OF_CSI2_BE_SOC_STREAMS
 
 struct ipu_isys;
 struct ipu_isys_csi2_be_soc;
@@ -41,10 +43,31 @@ struct output_pin_data {
 	struct ipu_isys_queue *aq;
 };
 
+/*
+ * struct ipu_isys_sub_stream_vc
+ */
+struct ipu_isys_sub_stream_vc {
+	unsigned int substream;	/* sub stream id */
+	int vc;	/* VC number */
+	u32 width;
+	u32 height;
+	unsigned int dt;
+	unsigned int code;
+};
+
+#define SUB_STREAM_CODE(value) ((value) & 0xFFFF)
+#define SUB_STREAM_H(value) (((value) >> 16) & 0xFFFF)
+#define SUB_STREAM_W(value) (((value) >> 32) & 0xFFFF)
+#define SUB_STREAM_DT(value) (((value) >> 48) & 0xFF)
+#define SUB_STREAM_VC_ID(value) ((value) >> 56 & 0xFF)
+#define SUB_STREAM_SET_VALUE(vc_id, stream_state) \
+	((((vc_id) << 8) & 0xFF00) | (stream_state))
+
 struct ipu_isys_pipeline {
 	struct media_pipeline pipe;
 	struct media_pad *external;
 	atomic_t sequence;
+	int last_sequence;
 	unsigned int seq_index;
 	struct sequence_info seq[IPU_ISYS_MAX_PARALLEL_SOF];
 	int source;	/* SSI stream source */
@@ -59,6 +82,7 @@ struct ipu_isys_pipeline {
 	 * Number of capture queues, write access serialised using struct
 	 * ipu_isys.stream_mutex
 	 */
+	/* If it supports vc, this is number of links for the same vc. */
 	int nr_queues;
 	int nr_streaming;	/* Number of capture queues streaming */
 	int streaming;	/* Has streaming been really started? */
@@ -92,6 +116,7 @@ struct ipu_isys_pipeline {
 	unsigned int stream_id;
 	struct media_graph graph;
 	struct media_entity_enum entity_enum;
+	struct ipu_isys_sub_stream_vc asv[CSI2_BE_SOC_SOURCE_PADS_NUM];
 };
 
 #define to_ipu_isys_pipeline(__pipe)				\
diff --git a/drivers/media/pci/intel/ipu4/ipu-platform-isys.h b/drivers/media/pci/intel/ipu4/ipu-platform-isys.h
index dfd379997..e5df4fabf 100644
--- a/drivers/media/pci/intel/ipu4/ipu-platform-isys.h
+++ b/drivers/media/pci/intel/ipu4/ipu-platform-isys.h
@@ -8,6 +8,8 @@
 
 #define IPU_ISYS_ENTITY_PREFIX		"Intel IPU4"
 
+#define IPU_ISYS_CSI2_ENTITY_PREFIX	"Intel IPU4 CSI-2"
+
 /*
  * FW support max 8 streams
  */
diff --git a/include/uapi/linux/ipu-isys.h b/include/uapi/linux/ipu-isys.h
index aefc9615c..f580aee1c 100644
--- a/include/uapi/linux/ipu-isys.h
+++ b/include/uapi/linux/ipu-isys.h
@@ -8,6 +8,9 @@
 
 #define V4L2_CID_IPU_ISA_EN	(V4L2_CID_IPU_BASE + 1)
 #define V4L2_CID_IPU_STORE_CSI2_HEADER	(V4L2_CID_IPU_BASE + 2)
+#define V4L2_CID_IPU_ISYS_COMPRESSION	(V4L2_CID_IPU_BASE + 3)
+#define V4L2_CID_IPU_QUERY_SUB_STREAM	(V4L2_CID_IPU_BASE + 4)
+#define V4L2_CID_IPU_SET_SUB_STREAM	(V4L2_CID_IPU_BASE + 5)
 
 #define V4L2_IPU_ISA_EN_BLC	(1 << 0)
 #define V4L2_IPU_ISA_EN_LSC	(1 << 1)
-- 
2.34.1

