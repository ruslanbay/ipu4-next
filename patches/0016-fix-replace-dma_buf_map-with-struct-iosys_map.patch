From 22d5f63fa73987324e143df53c16098dba1b6f35 Mon Sep 17 00:00:00 2001
From: ruslanbay <67730802+ruslanbay@users.noreply.github.com>
Date: Sat, 29 Nov 2025 07:16:04 +0100
Subject: [PATCH 16/16] fix: replace dma_buf_map with struct iosys_map

https://github.com/intel/linux-intel-lts/blob/lts-v6.1.120-linux-241226T022850Z/drivers/media/pci/intel/ipu-psys.c
---
 drivers/media/pci/intel/ipu-psys.c | 79 ++++++++++++++++++++----------
 drivers/media/pci/intel/ipu-psys.h | 25 ++++++++--
 2 files changed, 75 insertions(+), 29 deletions(-)

diff --git a/drivers/media/pci/intel/ipu-psys.c b/drivers/media/pci/intel/ipu-psys.c
index 71d1adf44..b1498f64f 100644
--- a/drivers/media/pci/intel/ipu-psys.c
+++ b/drivers/media/pci/intel/ipu-psys.c
@@ -350,34 +350,30 @@ static int ipu_dma_buf_begin_cpu_access(struct dma_buf *dma_buf,
 	return -ENOTTY;
 }
 
-static int ipu_dma_buf_vmap(struct dma_buf *dmabuf, struct dma_buf_map *map)
+static int ipu_dma_buf_vmap(struct dma_buf *dmabuf, struct iosys_map *map)
 {
 	struct dma_buf_attachment *attach;
 	struct ipu_dma_buf_attach *ipu_attach;
-    void *vaddr;
 
 	if (list_empty(&dmabuf->attachments))
-		return -ENOMEM;
+		return -EINVAL;
 
 	attach = list_last_entry(&dmabuf->attachments,
 				 struct dma_buf_attachment, node);
 	ipu_attach = attach->priv;
 
 	if (!ipu_attach || !ipu_attach->pages || !ipu_attach->npages)
-		return -ENOMEM;
-
-	vaddr = vm_map_ram(ipu_attach->pages,
-			  ipu_attach->npages, 0);
-
-    if (IS_ERR(vaddr))
-	return PTR_ERR(vaddr);
+		return -EINVAL;
 
-    dma_buf_map_set_vaddr(map, vaddr);
+	map->vaddr = vm_map_ram(ipu_attach->pages, ipu_attach->npages, 0);
+	map->is_iomem = false;
+	if (!map->vaddr)
+		return -EINVAL;
 
-    return 0;
+	return 0;
 }
 
-static void ipu_dma_buf_vunmap(struct dma_buf *dmabuf, struct dma_buf_map *map)
+static void ipu_dma_buf_vunmap(struct dma_buf *dmabuf, struct iosys_map *map)
 {
 	struct dma_buf_attachment *attach;
 	struct ipu_dma_buf_attach *ipu_attach;
@@ -395,7 +391,7 @@ static void ipu_dma_buf_vunmap(struct dma_buf *dmabuf, struct dma_buf_map *map)
 	vm_unmap_ram(map->vaddr, ipu_attach->npages);
 }
 
-static struct dma_buf_ops ipu_dma_buf_ops = {
+struct dma_buf_ops ipu_dma_buf_ops = {
 	.attach = ipu_dma_buf_attach,
 	.detach = ipu_dma_buf_detach,
 	.map_dma_buf = ipu_dma_buf_map,
@@ -450,12 +446,36 @@ static int ipu_psys_open(struct inode *inode, struct file *file)
 	return rval;
 }
 
+static inline void ipu_psys_kbuf_unmap(struct ipu_psys_kbuffer *kbuf)
+{
+	if (!kbuf)
+		return;
+
+	kbuf->valid = false;
+	if (kbuf->kaddr) {
+		struct iosys_map dmap;
+
+		iosys_map_set_vaddr(&dmap, kbuf->kaddr);
+		dma_buf_vunmap(kbuf->dbuf, &dmap);
+	}
+	if (kbuf->sgt)
+		dma_buf_unmap_attachment(kbuf->db_attach,
+					 kbuf->sgt,
+					 DMA_BIDIRECTIONAL);
+	if (kbuf->db_attach)
+		dma_buf_detach(kbuf->dbuf, kbuf->db_attach);
+	dma_buf_put(kbuf->dbuf);
+
+	kbuf->db_attach = NULL;
+	kbuf->dbuf = NULL;
+	kbuf->sgt = NULL;
+}
+
 static int ipu_psys_release(struct inode *inode, struct file *file)
 {
 	struct ipu_psys *psys = inode_to_ipu_psys(inode);
 	struct ipu_psys_fh *fh = file->private_data;
 	struct ipu_psys_kbuffer *kbuf, *kbuf0;
-    struct dma_buf_map map;
 
 	mutex_lock(&fh->mutex);
 	/* clean up buffers */
@@ -466,9 +486,13 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 			if (kbuf->dbuf && kbuf->db_attach) {
 				struct dma_buf *dbuf;
 
-				map = (struct dma_buf_map)DMA_BUF_MAP_INIT_VADDR(kbuf->kaddr);
 				kbuf->valid = false;
-				dma_buf_vunmap(kbuf->dbuf, &map);
+				if (kbuf->kaddr) {
+					struct iosys_map dmap;
+			
+					iosys_map_set_vaddr(&dmap, kbuf->kaddr);
+					dma_buf_vunmap(kbuf->dbuf, &dmap);
+				}
 				dma_buf_unmap_attachment(kbuf->db_attach,
 							 kbuf->sgt,
 							 DMA_BIDIRECTIONAL);
@@ -485,7 +509,7 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 			}
 		}
 	}
-	mutex_unlock(&fh->mutex);
+    mutex_unlock(&fh->mutex);
 
 	mutex_lock(&psys->mutex);
 	list_del(&fh->list);
@@ -496,7 +520,7 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 	mutex_destroy(&fh->mutex);
 	kfree(fh);
 
-	return 0;
+    return 0; 
 }
 
 static int ipu_psys_getbuf(struct ipu_psys_buffer *buf, struct ipu_psys_fh *fh)
@@ -564,7 +588,9 @@ static long ipu_psys_mapbuf(int fd, struct ipu_psys_fh *fh)
 	struct ipu_psys *psys = fh->psys;
 	struct ipu_psys_kbuffer *kbuf;
 	struct dma_buf *dbuf;
-    struct dma_buf_map map;
+    struct iosys_map dmap = {
+		.is_iomem = false,
+	};
 	int ret;
 
 	mutex_lock(&fh->mutex);
@@ -620,12 +646,12 @@ static long ipu_psys_mapbuf(int fd, struct ipu_psys_fh *fh)
 
 	kbuf->dma_addr = sg_dma_address(kbuf->sgt->sgl);
 
-	ret = dma_buf_vmap(kbuf->dbuf, &map);
+	ret = dma_buf_vmap(kbuf->dbuf, &dmap);
 	if (ret) {
 		ret = -EINVAL;
 		goto error_unmap;
 	}
-    kbuf->kaddr = map.vaddr;
+    kbuf->kaddr = dmap.vaddr;
 
 mapbuf_end:
 
@@ -660,7 +686,9 @@ static long ipu_psys_unmapbuf(int fd, struct ipu_psys_fh *fh)
 	struct ipu_psys_kbuffer *kbuf;
 	struct ipu_psys *psys = fh->psys;
 	struct dma_buf *dmabuf;
-    struct dma_buf_map map;
+    struct iosys_map dmap = {
+		.is_iomem = false,
+	};
 
 	mutex_lock(&fh->mutex);
 	kbuf = ipu_psys_lookup_kbuffer(fh, fd);
@@ -670,12 +698,10 @@ static long ipu_psys_unmapbuf(int fd, struct ipu_psys_fh *fh)
 		return -EINVAL;
 	}
 
-    map = (struct dma_buf_map)DMA_BUF_MAP_INIT_VADDR(kbuf->kaddr);
-
 	/* From now on it is not safe to use this kbuffer */
 	kbuf->valid = false;
 
-	dma_buf_vunmap(kbuf->dbuf, &map);
+	dma_buf_vunmap(kbuf->dbuf, &dmap);
 	dma_buf_unmap_attachment(kbuf->db_attach, kbuf->sgt, DMA_BIDIRECTIONAL);
 
 	dma_buf_detach(kbuf->dbuf, kbuf->db_attach);
@@ -1594,3 +1620,4 @@ MODULE_AUTHOR("Zaikuo Wang <zaikuo.wang@intel.com>");
 MODULE_AUTHOR("Yunliang Ding <yunliang.ding@intel.com>");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Intel ipu processing system driver");
+MODULE_IMPORT_NS(DMA_BUF);
diff --git a/drivers/media/pci/intel/ipu-psys.h b/drivers/media/pci/intel/ipu-psys.h
index bf888b38b..b0eef0685 100644
--- a/drivers/media/pci/intel/ipu-psys.h
+++ b/drivers/media/pci/intel/ipu-psys.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright (C) 2013 - 2018 Intel Corporation */
+/* Copyright (C) 2013 - 2020 Intel Corporation */
 
 #ifndef IPU_PSYS_H
 #define IPU_PSYS_H
@@ -52,6 +52,7 @@ struct ipu_resource_alloc {
  * yet reserve real IPU resources).
  */
 #define IPU_PSYS_RESOURCE_OVERALLOC 2	/* Some room for ABI / ext lib delta */
+/* resource size may need expand for new resource model */
 struct ipu_psys_resource_pool {
 	u32 cells;	/* Bitmask of cells allocated */
 	struct ipu_resource dev_channels[IPU_FW_PSYS_N_DEV_CHN_ID +
@@ -60,12 +61,15 @@ struct ipu_psys_resource_pool {
 				       IPU_PSYS_RESOURCE_OVERALLOC];
 	struct ipu_resource dfms[IPU_FW_PSYS_N_DEV_DFM_ID +
 				 IPU_PSYS_RESOURCE_OVERALLOC];
+	DECLARE_BITMAP(cmd_queues, 32);
+	/* Protects cmd_queues bitmap */
+	spinlock_t queues_lock;
 };
 
 /*
  * This struct keeps book of the resources allocated for a specific PG.
  * It is used for freeing up resources from struct ipu_psys_resources
- * when the PG is released from IPU4 (or model of IPU4).
+ * when the PG is released from IPU (or model of IPU).
  */
 struct ipu_psys_resource_alloc {
 	u32 cells;	/* Bitmask of cells needed */
@@ -96,8 +100,10 @@ struct ipu_psys {
 	struct task_struct *sched_cmd_thread;
 	struct work_struct watchdog_work;
 	wait_queue_head_t sched_cmd_wq;
-	atomic_t wakeup_sched_thread_count;
+	atomic_t wakeup_sched_thread_count;  /* Psys schedule thread wakeup count */
+#ifdef CONFIG_DEBUG_FS
 	struct dentry *debugfsdir;
+#endif
 
 	/* Resources needed to be managed for process groups */
 	struct ipu_psys_resource_pool resource_pool_running;
@@ -112,6 +118,8 @@ struct ipu_psys {
 
 	int active_kcmds, started_kcmds;
 	void *fwcom;
+
+	int power_gating;
 };
 
 struct ipu_psys_fh {
@@ -136,6 +144,7 @@ struct ipu_psys_kcmd {
 	struct ipu_psys_fh *fh;
 	struct list_head list;
 	struct list_head started_list;
+	struct ipu_psys_buffer_set *kbuf_set;
 	enum ipu_psys_cmd_state state;
 	void *pg_manifest;
 	size_t pg_manifest_size;
@@ -147,6 +156,10 @@ struct ipu_psys_kcmd {
 	u64 user_token;
 	u64 issue_id;
 	u32 priority;
+	u32 kernel_enable_bitmap[4];
+	u32 terminal_enable_bitmap[4];
+	u32 routing_enable_bitmap[4];
+	u32 rbm[5];
 	struct ipu_buttress_constraint constraint;
 	struct ipu_psys_event ev;
 	struct timer_list watchdog;
@@ -185,6 +198,7 @@ long ipu_psys_compat_ioctl32(struct file *file, unsigned int cmd,
 #endif
 
 void ipu_psys_setup_hw(struct ipu_psys *psys);
+void ipu_psys_subdomains_power(struct ipu_psys *psys, bool on);
 void ipu_psys_handle_events(struct ipu_psys *psys);
 int ipu_psys_kcmd_new(struct ipu_psys_command *cmd, struct ipu_psys_fh *fh);
 void ipu_psys_run_next(struct ipu_psys *psys);
@@ -192,8 +206,13 @@ void ipu_psys_watchdog_work(struct work_struct *work);
 struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size);
 struct ipu_psys_kbuffer *
 ipu_psys_lookup_kbuffer(struct ipu_psys_fh *fh, int fd);
+int ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh,
+			   struct ipu_psys_kbuffer *kbuf);
 struct ipu_psys_kbuffer *
 ipu_psys_lookup_kbuffer_by_kaddr(struct ipu_psys_fh *fh, void *kaddr);
+#ifdef IPU_PSYS_GPC
+int ipu_psys_gpc_init_debugfs(struct ipu_psys *psys);
+#endif
 int ipu_psys_resource_pool_init(struct ipu_psys_resource_pool *pool);
 void ipu_psys_resource_pool_cleanup(struct ipu_psys_resource_pool *pool);
 struct ipu_psys_kcmd *ipu_get_completed_kcmd(struct ipu_psys_fh *fh);
-- 
2.34.1

